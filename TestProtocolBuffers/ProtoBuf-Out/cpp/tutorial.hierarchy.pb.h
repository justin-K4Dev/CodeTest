// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tutorial.hierarchy.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tutorial_2ehierarchy_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tutorial_2ehierarchy_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tutorial_2ehierarchy_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tutorial_2ehierarchy_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tutorial_2ehierarchy_2eproto;
class ClientToLogin;
struct ClientToLoginDefaultTypeInternal;
extern ClientToLoginDefaultTypeInternal _ClientToLogin_default_instance_;
class ClientToLoginMessage;
struct ClientToLoginMessageDefaultTypeInternal;
extern ClientToLoginMessageDefaultTypeInternal _ClientToLoginMessage_default_instance_;
class ClientToLoginMessage_MyHome;
struct ClientToLoginMessage_MyHomeDefaultTypeInternal;
extern ClientToLoginMessage_MyHomeDefaultTypeInternal _ClientToLoginMessage_MyHome_default_instance_;
class ClientToLoginReq;
struct ClientToLoginReqDefaultTypeInternal;
extern ClientToLoginReqDefaultTypeInternal _ClientToLoginReq_default_instance_;
class ClientToLoginReq_LoginReq;
struct ClientToLoginReq_LoginReqDefaultTypeInternal;
extern ClientToLoginReq_LoginReqDefaultTypeInternal _ClientToLoginReq_LoginReq_default_instance_;
class ClientToLoginReq_LogoutReq;
struct ClientToLoginReq_LogoutReqDefaultTypeInternal;
extern ClientToLoginReq_LogoutReqDefaultTypeInternal _ClientToLoginReq_LogoutReq_default_instance_;
class ClientToLoginRes;
struct ClientToLoginResDefaultTypeInternal;
extern ClientToLoginResDefaultTypeInternal _ClientToLoginRes_default_instance_;
class ClientToLoginRes_LoginRes;
struct ClientToLoginRes_LoginResDefaultTypeInternal;
extern ClientToLoginRes_LoginResDefaultTypeInternal _ClientToLoginRes_LoginRes_default_instance_;
class ClientToLoginRes_LogoutRes;
struct ClientToLoginRes_LogoutResDefaultTypeInternal;
extern ClientToLoginRes_LogoutResDefaultTypeInternal _ClientToLoginRes_LogoutRes_default_instance_;
class MyHomeObjectSlotInfo;
struct MyHomeObjectSlotInfoDefaultTypeInternal;
extern MyHomeObjectSlotInfoDefaultTypeInternal _MyHomeObjectSlotInfo_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ClientToLogin* Arena::CreateMaybeMessage<::ClientToLogin>(Arena*);
template<> ::ClientToLoginMessage* Arena::CreateMaybeMessage<::ClientToLoginMessage>(Arena*);
template<> ::ClientToLoginMessage_MyHome* Arena::CreateMaybeMessage<::ClientToLoginMessage_MyHome>(Arena*);
template<> ::ClientToLoginReq* Arena::CreateMaybeMessage<::ClientToLoginReq>(Arena*);
template<> ::ClientToLoginReq_LoginReq* Arena::CreateMaybeMessage<::ClientToLoginReq_LoginReq>(Arena*);
template<> ::ClientToLoginReq_LogoutReq* Arena::CreateMaybeMessage<::ClientToLoginReq_LogoutReq>(Arena*);
template<> ::ClientToLoginRes* Arena::CreateMaybeMessage<::ClientToLoginRes>(Arena*);
template<> ::ClientToLoginRes_LoginRes* Arena::CreateMaybeMessage<::ClientToLoginRes_LoginRes>(Arena*);
template<> ::ClientToLoginRes_LogoutRes* Arena::CreateMaybeMessage<::ClientToLoginRes_LogoutRes>(Arena*);
template<> ::MyHomeObjectSlotInfo* Arena::CreateMaybeMessage<::MyHomeObjectSlotInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum ClientToLoginRes_LoginServerErrorCode : int {
  ClientToLoginRes_LoginServerErrorCode_Success = 0,
  ClientToLoginRes_LoginServerErrorCode_DupLogin = 1,
  ClientToLoginRes_LoginServerErrorCode_Moving = 2,
  ClientToLoginRes_LoginServerErrorCode_DbError = 3,
  ClientToLoginRes_LoginServerErrorCode_KickFail = 4,
  ClientToLoginRes_LoginServerErrorCode_NotCorrectPassword = 5,
  ClientToLoginRes_LoginServerErrorCode_NotFoundUser = 6,
  ClientToLoginRes_LoginServerErrorCode_NoGameServer = 7,
  ClientToLoginRes_LoginServerErrorCode_LoginPending = 8,
  ClientToLoginRes_LoginServerErrorCode_ClientToLoginRes_LoginServerErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ClientToLoginRes_LoginServerErrorCode_ClientToLoginRes_LoginServerErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ClientToLoginRes_LoginServerErrorCode_IsValid(int value);
constexpr ClientToLoginRes_LoginServerErrorCode ClientToLoginRes_LoginServerErrorCode_LoginServerErrorCode_MIN = ClientToLoginRes_LoginServerErrorCode_Success;
constexpr ClientToLoginRes_LoginServerErrorCode ClientToLoginRes_LoginServerErrorCode_LoginServerErrorCode_MAX = ClientToLoginRes_LoginServerErrorCode_LoginPending;
constexpr int ClientToLoginRes_LoginServerErrorCode_LoginServerErrorCode_ARRAYSIZE = ClientToLoginRes_LoginServerErrorCode_LoginServerErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientToLoginRes_LoginServerErrorCode_descriptor();
template<typename T>
inline const std::string& ClientToLoginRes_LoginServerErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientToLoginRes_LoginServerErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientToLoginRes_LoginServerErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClientToLoginRes_LoginServerErrorCode_descriptor(), enum_t_value);
}
inline bool ClientToLoginRes_LoginServerErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientToLoginRes_LoginServerErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClientToLoginRes_LoginServerErrorCode>(
    ClientToLoginRes_LoginServerErrorCode_descriptor(), name, value);
}
// ===================================================================

class MyHomeObjectSlotInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MyHomeObjectSlotInfo) */ {
 public:
  inline MyHomeObjectSlotInfo() : MyHomeObjectSlotInfo(nullptr) {}
  ~MyHomeObjectSlotInfo() override;
  explicit constexpr MyHomeObjectSlotInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MyHomeObjectSlotInfo(const MyHomeObjectSlotInfo& from);
  MyHomeObjectSlotInfo(MyHomeObjectSlotInfo&& from) noexcept
    : MyHomeObjectSlotInfo() {
    *this = ::std::move(from);
  }

  inline MyHomeObjectSlotInfo& operator=(const MyHomeObjectSlotInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MyHomeObjectSlotInfo& operator=(MyHomeObjectSlotInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MyHomeObjectSlotInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MyHomeObjectSlotInfo* internal_default_instance() {
    return reinterpret_cast<const MyHomeObjectSlotInfo*>(
               &_MyHomeObjectSlotInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MyHomeObjectSlotInfo& a, MyHomeObjectSlotInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MyHomeObjectSlotInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MyHomeObjectSlotInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MyHomeObjectSlotInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MyHomeObjectSlotInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MyHomeObjectSlotInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MyHomeObjectSlotInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MyHomeObjectSlotInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MyHomeObjectSlotInfo";
  }
  protected:
  explicit MyHomeObjectSlotInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotNumFieldNumber = 1,
    kObjectIdFieldNumber = 2,
  };
  // int32 slotNum = 1;
  void clear_slotnum();
  int32_t slotnum() const;
  void set_slotnum(int32_t value);
  private:
  int32_t _internal_slotnum() const;
  void _internal_set_slotnum(int32_t value);
  public:

  // int32 objectId = 2;
  void clear_objectid();
  int32_t objectid() const;
  void set_objectid(int32_t value);
  private:
  int32_t _internal_objectid() const;
  void _internal_set_objectid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MyHomeObjectSlotInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t slotnum_;
  int32_t objectid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tutorial_2ehierarchy_2eproto;
};
// -------------------------------------------------------------------

class ClientToLoginReq_LoginReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientToLoginReq.LoginReq) */ {
 public:
  inline ClientToLoginReq_LoginReq() : ClientToLoginReq_LoginReq(nullptr) {}
  ~ClientToLoginReq_LoginReq() override;
  explicit constexpr ClientToLoginReq_LoginReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientToLoginReq_LoginReq(const ClientToLoginReq_LoginReq& from);
  ClientToLoginReq_LoginReq(ClientToLoginReq_LoginReq&& from) noexcept
    : ClientToLoginReq_LoginReq() {
    *this = ::std::move(from);
  }

  inline ClientToLoginReq_LoginReq& operator=(const ClientToLoginReq_LoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToLoginReq_LoginReq& operator=(ClientToLoginReq_LoginReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientToLoginReq_LoginReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientToLoginReq_LoginReq* internal_default_instance() {
    return reinterpret_cast<const ClientToLoginReq_LoginReq*>(
               &_ClientToLoginReq_LoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ClientToLoginReq_LoginReq& a, ClientToLoginReq_LoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToLoginReq_LoginReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToLoginReq_LoginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientToLoginReq_LoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientToLoginReq_LoginReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientToLoginReq_LoginReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClientToLoginReq_LoginReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToLoginReq_LoginReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientToLoginReq.LoginReq";
  }
  protected:
  explicit ClientToLoginReq_LoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kSecurtyTokenFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string securtyToken = 3;
  void clear_securtytoken();
  const std::string& securtytoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_securtytoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_securtytoken();
  PROTOBUF_NODISCARD std::string* release_securtytoken();
  void set_allocated_securtytoken(std::string* securtytoken);
  private:
  const std::string& _internal_securtytoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_securtytoken(const std::string& value);
  std::string* _internal_mutable_securtytoken();
  public:

  // @@protoc_insertion_point(class_scope:ClientToLoginReq.LoginReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr securtytoken_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tutorial_2ehierarchy_2eproto;
};
// -------------------------------------------------------------------

class ClientToLoginReq_LogoutReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ClientToLoginReq.LogoutReq) */ {
 public:
  inline ClientToLoginReq_LogoutReq() : ClientToLoginReq_LogoutReq(nullptr) {}
  explicit constexpr ClientToLoginReq_LogoutReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientToLoginReq_LogoutReq(const ClientToLoginReq_LogoutReq& from);
  ClientToLoginReq_LogoutReq(ClientToLoginReq_LogoutReq&& from) noexcept
    : ClientToLoginReq_LogoutReq() {
    *this = ::std::move(from);
  }

  inline ClientToLoginReq_LogoutReq& operator=(const ClientToLoginReq_LogoutReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToLoginReq_LogoutReq& operator=(ClientToLoginReq_LogoutReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientToLoginReq_LogoutReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientToLoginReq_LogoutReq* internal_default_instance() {
    return reinterpret_cast<const ClientToLoginReq_LogoutReq*>(
               &_ClientToLoginReq_LogoutReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ClientToLoginReq_LogoutReq& a, ClientToLoginReq_LogoutReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToLoginReq_LogoutReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToLoginReq_LogoutReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientToLoginReq_LogoutReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientToLoginReq_LogoutReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ClientToLoginReq_LogoutReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ClientToLoginReq_LogoutReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientToLoginReq.LogoutReq";
  }
  protected:
  explicit ClientToLoginReq_LogoutReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ClientToLoginReq.LogoutReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tutorial_2ehierarchy_2eproto;
};
// -------------------------------------------------------------------

class ClientToLoginReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientToLoginReq) */ {
 public:
  inline ClientToLoginReq() : ClientToLoginReq(nullptr) {}
  ~ClientToLoginReq() override;
  explicit constexpr ClientToLoginReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientToLoginReq(const ClientToLoginReq& from);
  ClientToLoginReq(ClientToLoginReq&& from) noexcept
    : ClientToLoginReq() {
    *this = ::std::move(from);
  }

  inline ClientToLoginReq& operator=(const ClientToLoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToLoginReq& operator=(ClientToLoginReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientToLoginReq& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kLoginReq = 1,
    kLogoutReq = 2,
    MSG_NOT_SET = 0,
  };

  static inline const ClientToLoginReq* internal_default_instance() {
    return reinterpret_cast<const ClientToLoginReq*>(
               &_ClientToLoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ClientToLoginReq& a, ClientToLoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToLoginReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToLoginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientToLoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientToLoginReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientToLoginReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClientToLoginReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToLoginReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientToLoginReq";
  }
  protected:
  explicit ClientToLoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClientToLoginReq_LoginReq LoginReq;
  typedef ClientToLoginReq_LogoutReq LogoutReq;

  // accessors -------------------------------------------------------

  enum : int {
    kLoginReqFieldNumber = 1,
    kLogoutReqFieldNumber = 2,
  };
  // .ClientToLoginReq.LoginReq loginReq = 1;
  bool has_loginreq() const;
  private:
  bool _internal_has_loginreq() const;
  public:
  void clear_loginreq();
  const ::ClientToLoginReq_LoginReq& loginreq() const;
  PROTOBUF_NODISCARD ::ClientToLoginReq_LoginReq* release_loginreq();
  ::ClientToLoginReq_LoginReq* mutable_loginreq();
  void set_allocated_loginreq(::ClientToLoginReq_LoginReq* loginreq);
  private:
  const ::ClientToLoginReq_LoginReq& _internal_loginreq() const;
  ::ClientToLoginReq_LoginReq* _internal_mutable_loginreq();
  public:
  void unsafe_arena_set_allocated_loginreq(
      ::ClientToLoginReq_LoginReq* loginreq);
  ::ClientToLoginReq_LoginReq* unsafe_arena_release_loginreq();

  // .ClientToLoginReq.LogoutReq logoutReq = 2;
  bool has_logoutreq() const;
  private:
  bool _internal_has_logoutreq() const;
  public:
  void clear_logoutreq();
  const ::ClientToLoginReq_LogoutReq& logoutreq() const;
  PROTOBUF_NODISCARD ::ClientToLoginReq_LogoutReq* release_logoutreq();
  ::ClientToLoginReq_LogoutReq* mutable_logoutreq();
  void set_allocated_logoutreq(::ClientToLoginReq_LogoutReq* logoutreq);
  private:
  const ::ClientToLoginReq_LogoutReq& _internal_logoutreq() const;
  ::ClientToLoginReq_LogoutReq* _internal_mutable_logoutreq();
  public:
  void unsafe_arena_set_allocated_logoutreq(
      ::ClientToLoginReq_LogoutReq* logoutreq);
  ::ClientToLoginReq_LogoutReq* unsafe_arena_release_logoutreq();

  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:ClientToLoginReq)
 private:
  class _Internal;
  void set_has_loginreq();
  void set_has_logoutreq();

  inline bool has_msg() const;
  inline void clear_has_msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MsgUnion {
    constexpr MsgUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::ClientToLoginReq_LoginReq* loginreq_;
    ::ClientToLoginReq_LogoutReq* logoutreq_;
  } msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_tutorial_2ehierarchy_2eproto;
};
// -------------------------------------------------------------------

class ClientToLoginRes_LoginRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientToLoginRes.LoginRes) */ {
 public:
  inline ClientToLoginRes_LoginRes() : ClientToLoginRes_LoginRes(nullptr) {}
  ~ClientToLoginRes_LoginRes() override;
  explicit constexpr ClientToLoginRes_LoginRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientToLoginRes_LoginRes(const ClientToLoginRes_LoginRes& from);
  ClientToLoginRes_LoginRes(ClientToLoginRes_LoginRes&& from) noexcept
    : ClientToLoginRes_LoginRes() {
    *this = ::std::move(from);
  }

  inline ClientToLoginRes_LoginRes& operator=(const ClientToLoginRes_LoginRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToLoginRes_LoginRes& operator=(ClientToLoginRes_LoginRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientToLoginRes_LoginRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientToLoginRes_LoginRes* internal_default_instance() {
    return reinterpret_cast<const ClientToLoginRes_LoginRes*>(
               &_ClientToLoginRes_LoginRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ClientToLoginRes_LoginRes& a, ClientToLoginRes_LoginRes& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToLoginRes_LoginRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToLoginRes_LoginRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientToLoginRes_LoginRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientToLoginRes_LoginRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientToLoginRes_LoginRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClientToLoginRes_LoginRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToLoginRes_LoginRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientToLoginRes.LoginRes";
  }
  protected:
  explicit ClientToLoginRes_LoginRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameServerAddrFieldNumber = 1,
    kOtpFieldNumber = 3,
    kGameServerPortFieldNumber = 2,
  };
  // string gameServerAddr = 1;
  void clear_gameserveraddr();
  const std::string& gameserveraddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gameserveraddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gameserveraddr();
  PROTOBUF_NODISCARD std::string* release_gameserveraddr();
  void set_allocated_gameserveraddr(std::string* gameserveraddr);
  private:
  const std::string& _internal_gameserveraddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gameserveraddr(const std::string& value);
  std::string* _internal_mutable_gameserveraddr();
  public:

  // string otp = 3;
  void clear_otp();
  const std::string& otp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_otp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_otp();
  PROTOBUF_NODISCARD std::string* release_otp();
  void set_allocated_otp(std::string* otp);
  private:
  const std::string& _internal_otp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_otp(const std::string& value);
  std::string* _internal_mutable_otp();
  public:

  // int32 gameServerPort = 2;
  void clear_gameserverport();
  int32_t gameserverport() const;
  void set_gameserverport(int32_t value);
  private:
  int32_t _internal_gameserverport() const;
  void _internal_set_gameserverport(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ClientToLoginRes.LoginRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gameserveraddr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr otp_;
  int32_t gameserverport_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tutorial_2ehierarchy_2eproto;
};
// -------------------------------------------------------------------

class ClientToLoginRes_LogoutRes final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ClientToLoginRes.LogoutRes) */ {
 public:
  inline ClientToLoginRes_LogoutRes() : ClientToLoginRes_LogoutRes(nullptr) {}
  explicit constexpr ClientToLoginRes_LogoutRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientToLoginRes_LogoutRes(const ClientToLoginRes_LogoutRes& from);
  ClientToLoginRes_LogoutRes(ClientToLoginRes_LogoutRes&& from) noexcept
    : ClientToLoginRes_LogoutRes() {
    *this = ::std::move(from);
  }

  inline ClientToLoginRes_LogoutRes& operator=(const ClientToLoginRes_LogoutRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToLoginRes_LogoutRes& operator=(ClientToLoginRes_LogoutRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientToLoginRes_LogoutRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientToLoginRes_LogoutRes* internal_default_instance() {
    return reinterpret_cast<const ClientToLoginRes_LogoutRes*>(
               &_ClientToLoginRes_LogoutRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ClientToLoginRes_LogoutRes& a, ClientToLoginRes_LogoutRes& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToLoginRes_LogoutRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToLoginRes_LogoutRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientToLoginRes_LogoutRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientToLoginRes_LogoutRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ClientToLoginRes_LogoutRes& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ClientToLoginRes_LogoutRes& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientToLoginRes.LogoutRes";
  }
  protected:
  explicit ClientToLoginRes_LogoutRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ClientToLoginRes.LogoutRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tutorial_2ehierarchy_2eproto;
};
// -------------------------------------------------------------------

class ClientToLoginRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientToLoginRes) */ {
 public:
  inline ClientToLoginRes() : ClientToLoginRes(nullptr) {}
  ~ClientToLoginRes() override;
  explicit constexpr ClientToLoginRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientToLoginRes(const ClientToLoginRes& from);
  ClientToLoginRes(ClientToLoginRes&& from) noexcept
    : ClientToLoginRes() {
    *this = ::std::move(from);
  }

  inline ClientToLoginRes& operator=(const ClientToLoginRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToLoginRes& operator=(ClientToLoginRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientToLoginRes& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kLoginRes = 2,
    kLogoutRes = 3,
    MSG_NOT_SET = 0,
  };

  static inline const ClientToLoginRes* internal_default_instance() {
    return reinterpret_cast<const ClientToLoginRes*>(
               &_ClientToLoginRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ClientToLoginRes& a, ClientToLoginRes& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToLoginRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToLoginRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientToLoginRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientToLoginRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientToLoginRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClientToLoginRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToLoginRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientToLoginRes";
  }
  protected:
  explicit ClientToLoginRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClientToLoginRes_LoginRes LoginRes;
  typedef ClientToLoginRes_LogoutRes LogoutRes;

  typedef ClientToLoginRes_LoginServerErrorCode LoginServerErrorCode;
  static constexpr LoginServerErrorCode Success =
    ClientToLoginRes_LoginServerErrorCode_Success;
  static constexpr LoginServerErrorCode DupLogin =
    ClientToLoginRes_LoginServerErrorCode_DupLogin;
  static constexpr LoginServerErrorCode Moving =
    ClientToLoginRes_LoginServerErrorCode_Moving;
  static constexpr LoginServerErrorCode DbError =
    ClientToLoginRes_LoginServerErrorCode_DbError;
  static constexpr LoginServerErrorCode KickFail =
    ClientToLoginRes_LoginServerErrorCode_KickFail;
  static constexpr LoginServerErrorCode NotCorrectPassword =
    ClientToLoginRes_LoginServerErrorCode_NotCorrectPassword;
  static constexpr LoginServerErrorCode NotFoundUser =
    ClientToLoginRes_LoginServerErrorCode_NotFoundUser;
  static constexpr LoginServerErrorCode NoGameServer =
    ClientToLoginRes_LoginServerErrorCode_NoGameServer;
  static constexpr LoginServerErrorCode LoginPending =
    ClientToLoginRes_LoginServerErrorCode_LoginPending;
  static inline bool LoginServerErrorCode_IsValid(int value) {
    return ClientToLoginRes_LoginServerErrorCode_IsValid(value);
  }
  static constexpr LoginServerErrorCode LoginServerErrorCode_MIN =
    ClientToLoginRes_LoginServerErrorCode_LoginServerErrorCode_MIN;
  static constexpr LoginServerErrorCode LoginServerErrorCode_MAX =
    ClientToLoginRes_LoginServerErrorCode_LoginServerErrorCode_MAX;
  static constexpr int LoginServerErrorCode_ARRAYSIZE =
    ClientToLoginRes_LoginServerErrorCode_LoginServerErrorCode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LoginServerErrorCode_descriptor() {
    return ClientToLoginRes_LoginServerErrorCode_descriptor();
  }
  template<typename T>
  static inline const std::string& LoginServerErrorCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LoginServerErrorCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LoginServerErrorCode_Name.");
    return ClientToLoginRes_LoginServerErrorCode_Name(enum_t_value);
  }
  static inline bool LoginServerErrorCode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LoginServerErrorCode* value) {
    return ClientToLoginRes_LoginServerErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
    kLoginResFieldNumber = 2,
    kLogoutResFieldNumber = 3,
  };
  // .ClientToLoginRes.LoginServerErrorCode errorCode = 1;
  void clear_errorcode();
  ::ClientToLoginRes_LoginServerErrorCode errorcode() const;
  void set_errorcode(::ClientToLoginRes_LoginServerErrorCode value);
  private:
  ::ClientToLoginRes_LoginServerErrorCode _internal_errorcode() const;
  void _internal_set_errorcode(::ClientToLoginRes_LoginServerErrorCode value);
  public:

  // .ClientToLoginRes.LoginRes loginRes = 2;
  bool has_loginres() const;
  private:
  bool _internal_has_loginres() const;
  public:
  void clear_loginres();
  const ::ClientToLoginRes_LoginRes& loginres() const;
  PROTOBUF_NODISCARD ::ClientToLoginRes_LoginRes* release_loginres();
  ::ClientToLoginRes_LoginRes* mutable_loginres();
  void set_allocated_loginres(::ClientToLoginRes_LoginRes* loginres);
  private:
  const ::ClientToLoginRes_LoginRes& _internal_loginres() const;
  ::ClientToLoginRes_LoginRes* _internal_mutable_loginres();
  public:
  void unsafe_arena_set_allocated_loginres(
      ::ClientToLoginRes_LoginRes* loginres);
  ::ClientToLoginRes_LoginRes* unsafe_arena_release_loginres();

  // .ClientToLoginRes.LogoutRes logoutRes = 3;
  bool has_logoutres() const;
  private:
  bool _internal_has_logoutres() const;
  public:
  void clear_logoutres();
  const ::ClientToLoginRes_LogoutRes& logoutres() const;
  PROTOBUF_NODISCARD ::ClientToLoginRes_LogoutRes* release_logoutres();
  ::ClientToLoginRes_LogoutRes* mutable_logoutres();
  void set_allocated_logoutres(::ClientToLoginRes_LogoutRes* logoutres);
  private:
  const ::ClientToLoginRes_LogoutRes& _internal_logoutres() const;
  ::ClientToLoginRes_LogoutRes* _internal_mutable_logoutres();
  public:
  void unsafe_arena_set_allocated_logoutres(
      ::ClientToLoginRes_LogoutRes* logoutres);
  ::ClientToLoginRes_LogoutRes* unsafe_arena_release_logoutres();

  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:ClientToLoginRes)
 private:
  class _Internal;
  void set_has_loginres();
  void set_has_logoutres();

  inline bool has_msg() const;
  inline void clear_has_msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int errorcode_;
  union MsgUnion {
    constexpr MsgUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::ClientToLoginRes_LoginRes* loginres_;
    ::ClientToLoginRes_LogoutRes* logoutres_;
  } msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_tutorial_2ehierarchy_2eproto;
};
// -------------------------------------------------------------------

class ClientToLoginMessage_MyHome final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientToLoginMessage.MyHome) */ {
 public:
  inline ClientToLoginMessage_MyHome() : ClientToLoginMessage_MyHome(nullptr) {}
  ~ClientToLoginMessage_MyHome() override;
  explicit constexpr ClientToLoginMessage_MyHome(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientToLoginMessage_MyHome(const ClientToLoginMessage_MyHome& from);
  ClientToLoginMessage_MyHome(ClientToLoginMessage_MyHome&& from) noexcept
    : ClientToLoginMessage_MyHome() {
    *this = ::std::move(from);
  }

  inline ClientToLoginMessage_MyHome& operator=(const ClientToLoginMessage_MyHome& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToLoginMessage_MyHome& operator=(ClientToLoginMessage_MyHome&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientToLoginMessage_MyHome& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientToLoginMessage_MyHome* internal_default_instance() {
    return reinterpret_cast<const ClientToLoginMessage_MyHome*>(
               &_ClientToLoginMessage_MyHome_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ClientToLoginMessage_MyHome& a, ClientToLoginMessage_MyHome& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToLoginMessage_MyHome* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToLoginMessage_MyHome* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientToLoginMessage_MyHome* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientToLoginMessage_MyHome>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientToLoginMessage_MyHome& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClientToLoginMessage_MyHome& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToLoginMessage_MyHome* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientToLoginMessage.MyHome";
  }
  protected:
  explicit ClientToLoginMessage_MyHome(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotInfoFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .MyHomeObjectSlotInfo slotInfo = 2;
  int slotinfo_size() const;
  private:
  int _internal_slotinfo_size() const;
  public:
  void clear_slotinfo();
  ::MyHomeObjectSlotInfo* mutable_slotinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MyHomeObjectSlotInfo >*
      mutable_slotinfo();
  private:
  const ::MyHomeObjectSlotInfo& _internal_slotinfo(int index) const;
  ::MyHomeObjectSlotInfo* _internal_add_slotinfo();
  public:
  const ::MyHomeObjectSlotInfo& slotinfo(int index) const;
  ::MyHomeObjectSlotInfo* add_slotinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MyHomeObjectSlotInfo >&
      slotinfo() const;

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ClientToLoginMessage.MyHome)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MyHomeObjectSlotInfo > slotinfo_;
  int32_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tutorial_2ehierarchy_2eproto;
};
// -------------------------------------------------------------------

class ClientToLoginMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientToLoginMessage) */ {
 public:
  inline ClientToLoginMessage() : ClientToLoginMessage(nullptr) {}
  ~ClientToLoginMessage() override;
  explicit constexpr ClientToLoginMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientToLoginMessage(const ClientToLoginMessage& from);
  ClientToLoginMessage(ClientToLoginMessage&& from) noexcept
    : ClientToLoginMessage() {
    *this = ::std::move(from);
  }

  inline ClientToLoginMessage& operator=(const ClientToLoginMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToLoginMessage& operator=(ClientToLoginMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientToLoginMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kMyHome = 1,
    MSG_NOT_SET = 0,
  };

  static inline const ClientToLoginMessage* internal_default_instance() {
    return reinterpret_cast<const ClientToLoginMessage*>(
               &_ClientToLoginMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ClientToLoginMessage& a, ClientToLoginMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToLoginMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToLoginMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientToLoginMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientToLoginMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientToLoginMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClientToLoginMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToLoginMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientToLoginMessage";
  }
  protected:
  explicit ClientToLoginMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClientToLoginMessage_MyHome MyHome;

  // accessors -------------------------------------------------------

  enum : int {
    kMyHomeFieldNumber = 1,
  };
  // .ClientToLoginMessage.MyHome myHome = 1;
  bool has_myhome() const;
  private:
  bool _internal_has_myhome() const;
  public:
  void clear_myhome();
  const ::ClientToLoginMessage_MyHome& myhome() const;
  PROTOBUF_NODISCARD ::ClientToLoginMessage_MyHome* release_myhome();
  ::ClientToLoginMessage_MyHome* mutable_myhome();
  void set_allocated_myhome(::ClientToLoginMessage_MyHome* myhome);
  private:
  const ::ClientToLoginMessage_MyHome& _internal_myhome() const;
  ::ClientToLoginMessage_MyHome* _internal_mutable_myhome();
  public:
  void unsafe_arena_set_allocated_myhome(
      ::ClientToLoginMessage_MyHome* myhome);
  ::ClientToLoginMessage_MyHome* unsafe_arena_release_myhome();

  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:ClientToLoginMessage)
 private:
  class _Internal;
  void set_has_myhome();

  inline bool has_msg() const;
  inline void clear_has_msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MsgUnion {
    constexpr MsgUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::ClientToLoginMessage_MyHome* myhome_;
  } msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_tutorial_2ehierarchy_2eproto;
};
// -------------------------------------------------------------------

class ClientToLogin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientToLogin) */ {
 public:
  inline ClientToLogin() : ClientToLogin(nullptr) {}
  ~ClientToLogin() override;
  explicit constexpr ClientToLogin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientToLogin(const ClientToLogin& from);
  ClientToLogin(ClientToLogin&& from) noexcept
    : ClientToLogin() {
    *this = ::std::move(from);
  }

  inline ClientToLogin& operator=(const ClientToLogin& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToLogin& operator=(ClientToLogin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientToLogin& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kRequest = 1,
    kResponse = 2,
    kMessage = 3,
    MSG_NOT_SET = 0,
  };

  static inline const ClientToLogin* internal_default_instance() {
    return reinterpret_cast<const ClientToLogin*>(
               &_ClientToLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ClientToLogin& a, ClientToLogin& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientToLogin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToLogin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientToLogin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientToLogin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientToLogin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ClientToLogin& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientToLogin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClientToLogin";
  }
  protected:
  explicit ClientToLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 1,
    kResponseFieldNumber = 2,
    kMessageFieldNumber = 3,
  };
  // .ClientToLoginReq request = 1;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::ClientToLoginReq& request() const;
  PROTOBUF_NODISCARD ::ClientToLoginReq* release_request();
  ::ClientToLoginReq* mutable_request();
  void set_allocated_request(::ClientToLoginReq* request);
  private:
  const ::ClientToLoginReq& _internal_request() const;
  ::ClientToLoginReq* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::ClientToLoginReq* request);
  ::ClientToLoginReq* unsafe_arena_release_request();

  // .ClientToLoginRes response = 2;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::ClientToLoginRes& response() const;
  PROTOBUF_NODISCARD ::ClientToLoginRes* release_response();
  ::ClientToLoginRes* mutable_response();
  void set_allocated_response(::ClientToLoginRes* response);
  private:
  const ::ClientToLoginRes& _internal_response() const;
  ::ClientToLoginRes* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::ClientToLoginRes* response);
  ::ClientToLoginRes* unsafe_arena_release_response();

  // .ClientToLoginMessage message = 3;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::ClientToLoginMessage& message() const;
  PROTOBUF_NODISCARD ::ClientToLoginMessage* release_message();
  ::ClientToLoginMessage* mutable_message();
  void set_allocated_message(::ClientToLoginMessage* message);
  private:
  const ::ClientToLoginMessage& _internal_message() const;
  ::ClientToLoginMessage* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::ClientToLoginMessage* message);
  ::ClientToLoginMessage* unsafe_arena_release_message();

  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:ClientToLogin)
 private:
  class _Internal;
  void set_has_request();
  void set_has_response();
  void set_has_message();

  inline bool has_msg() const;
  inline void clear_has_msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MsgUnion {
    constexpr MsgUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::ClientToLoginReq* request_;
    ::ClientToLoginRes* response_;
    ::ClientToLoginMessage* message_;
  } msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_tutorial_2ehierarchy_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MyHomeObjectSlotInfo

// int32 slotNum = 1;
inline void MyHomeObjectSlotInfo::clear_slotnum() {
  slotnum_ = 0;
}
inline int32_t MyHomeObjectSlotInfo::_internal_slotnum() const {
  return slotnum_;
}
inline int32_t MyHomeObjectSlotInfo::slotnum() const {
  // @@protoc_insertion_point(field_get:MyHomeObjectSlotInfo.slotNum)
  return _internal_slotnum();
}
inline void MyHomeObjectSlotInfo::_internal_set_slotnum(int32_t value) {
  
  slotnum_ = value;
}
inline void MyHomeObjectSlotInfo::set_slotnum(int32_t value) {
  _internal_set_slotnum(value);
  // @@protoc_insertion_point(field_set:MyHomeObjectSlotInfo.slotNum)
}

// int32 objectId = 2;
inline void MyHomeObjectSlotInfo::clear_objectid() {
  objectid_ = 0;
}
inline int32_t MyHomeObjectSlotInfo::_internal_objectid() const {
  return objectid_;
}
inline int32_t MyHomeObjectSlotInfo::objectid() const {
  // @@protoc_insertion_point(field_get:MyHomeObjectSlotInfo.objectId)
  return _internal_objectid();
}
inline void MyHomeObjectSlotInfo::_internal_set_objectid(int32_t value) {
  
  objectid_ = value;
}
inline void MyHomeObjectSlotInfo::set_objectid(int32_t value) {
  _internal_set_objectid(value);
  // @@protoc_insertion_point(field_set:MyHomeObjectSlotInfo.objectId)
}

// -------------------------------------------------------------------

// ClientToLoginReq_LoginReq

// string id = 1;
inline void ClientToLoginReq_LoginReq::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& ClientToLoginReq_LoginReq::id() const {
  // @@protoc_insertion_point(field_get:ClientToLoginReq.LoginReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientToLoginReq_LoginReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientToLoginReq.LoginReq.id)
}
inline std::string* ClientToLoginReq_LoginReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ClientToLoginReq.LoginReq.id)
  return _s;
}
inline const std::string& ClientToLoginReq_LoginReq::_internal_id() const {
  return id_.Get();
}
inline void ClientToLoginReq_LoginReq::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClientToLoginReq_LoginReq::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClientToLoginReq_LoginReq::release_id() {
  // @@protoc_insertion_point(field_release:ClientToLoginReq.LoginReq.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClientToLoginReq_LoginReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientToLoginReq.LoginReq.id)
}

// string password = 2;
inline void ClientToLoginReq_LoginReq::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& ClientToLoginReq_LoginReq::password() const {
  // @@protoc_insertion_point(field_get:ClientToLoginReq.LoginReq.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientToLoginReq_LoginReq::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientToLoginReq.LoginReq.password)
}
inline std::string* ClientToLoginReq_LoginReq::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:ClientToLoginReq.LoginReq.password)
  return _s;
}
inline const std::string& ClientToLoginReq_LoginReq::_internal_password() const {
  return password_.Get();
}
inline void ClientToLoginReq_LoginReq::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClientToLoginReq_LoginReq::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClientToLoginReq_LoginReq::release_password() {
  // @@protoc_insertion_point(field_release:ClientToLoginReq.LoginReq.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClientToLoginReq_LoginReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientToLoginReq.LoginReq.password)
}

// string securtyToken = 3;
inline void ClientToLoginReq_LoginReq::clear_securtytoken() {
  securtytoken_.ClearToEmpty();
}
inline const std::string& ClientToLoginReq_LoginReq::securtytoken() const {
  // @@protoc_insertion_point(field_get:ClientToLoginReq.LoginReq.securtyToken)
  return _internal_securtytoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientToLoginReq_LoginReq::set_securtytoken(ArgT0&& arg0, ArgT... args) {
 
 securtytoken_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientToLoginReq.LoginReq.securtyToken)
}
inline std::string* ClientToLoginReq_LoginReq::mutable_securtytoken() {
  std::string* _s = _internal_mutable_securtytoken();
  // @@protoc_insertion_point(field_mutable:ClientToLoginReq.LoginReq.securtyToken)
  return _s;
}
inline const std::string& ClientToLoginReq_LoginReq::_internal_securtytoken() const {
  return securtytoken_.Get();
}
inline void ClientToLoginReq_LoginReq::_internal_set_securtytoken(const std::string& value) {
  
  securtytoken_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClientToLoginReq_LoginReq::_internal_mutable_securtytoken() {
  
  return securtytoken_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClientToLoginReq_LoginReq::release_securtytoken() {
  // @@protoc_insertion_point(field_release:ClientToLoginReq.LoginReq.securtyToken)
  return securtytoken_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClientToLoginReq_LoginReq::set_allocated_securtytoken(std::string* securtytoken) {
  if (securtytoken != nullptr) {
    
  } else {
    
  }
  securtytoken_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), securtytoken,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (securtytoken_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    securtytoken_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientToLoginReq.LoginReq.securtyToken)
}

// -------------------------------------------------------------------

// ClientToLoginReq_LogoutReq

// -------------------------------------------------------------------

// ClientToLoginReq

// .ClientToLoginReq.LoginReq loginReq = 1;
inline bool ClientToLoginReq::_internal_has_loginreq() const {
  return msg_case() == kLoginReq;
}
inline bool ClientToLoginReq::has_loginreq() const {
  return _internal_has_loginreq();
}
inline void ClientToLoginReq::set_has_loginreq() {
  _oneof_case_[0] = kLoginReq;
}
inline void ClientToLoginReq::clear_loginreq() {
  if (_internal_has_loginreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.loginreq_;
    }
    clear_has_msg();
  }
}
inline ::ClientToLoginReq_LoginReq* ClientToLoginReq::release_loginreq() {
  // @@protoc_insertion_point(field_release:ClientToLoginReq.loginReq)
  if (_internal_has_loginreq()) {
    clear_has_msg();
      ::ClientToLoginReq_LoginReq* temp = msg_.loginreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.loginreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ClientToLoginReq_LoginReq& ClientToLoginReq::_internal_loginreq() const {
  return _internal_has_loginreq()
      ? *msg_.loginreq_
      : reinterpret_cast< ::ClientToLoginReq_LoginReq&>(::_ClientToLoginReq_LoginReq_default_instance_);
}
inline const ::ClientToLoginReq_LoginReq& ClientToLoginReq::loginreq() const {
  // @@protoc_insertion_point(field_get:ClientToLoginReq.loginReq)
  return _internal_loginreq();
}
inline ::ClientToLoginReq_LoginReq* ClientToLoginReq::unsafe_arena_release_loginreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ClientToLoginReq.loginReq)
  if (_internal_has_loginreq()) {
    clear_has_msg();
    ::ClientToLoginReq_LoginReq* temp = msg_.loginreq_;
    msg_.loginreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToLoginReq::unsafe_arena_set_allocated_loginreq(::ClientToLoginReq_LoginReq* loginreq) {
  clear_msg();
  if (loginreq) {
    set_has_loginreq();
    msg_.loginreq_ = loginreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientToLoginReq.loginReq)
}
inline ::ClientToLoginReq_LoginReq* ClientToLoginReq::_internal_mutable_loginreq() {
  if (!_internal_has_loginreq()) {
    clear_msg();
    set_has_loginreq();
    msg_.loginreq_ = CreateMaybeMessage< ::ClientToLoginReq_LoginReq >(GetArenaForAllocation());
  }
  return msg_.loginreq_;
}
inline ::ClientToLoginReq_LoginReq* ClientToLoginReq::mutable_loginreq() {
  ::ClientToLoginReq_LoginReq* _msg = _internal_mutable_loginreq();
  // @@protoc_insertion_point(field_mutable:ClientToLoginReq.loginReq)
  return _msg;
}

// .ClientToLoginReq.LogoutReq logoutReq = 2;
inline bool ClientToLoginReq::_internal_has_logoutreq() const {
  return msg_case() == kLogoutReq;
}
inline bool ClientToLoginReq::has_logoutreq() const {
  return _internal_has_logoutreq();
}
inline void ClientToLoginReq::set_has_logoutreq() {
  _oneof_case_[0] = kLogoutReq;
}
inline void ClientToLoginReq::clear_logoutreq() {
  if (_internal_has_logoutreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.logoutreq_;
    }
    clear_has_msg();
  }
}
inline ::ClientToLoginReq_LogoutReq* ClientToLoginReq::release_logoutreq() {
  // @@protoc_insertion_point(field_release:ClientToLoginReq.logoutReq)
  if (_internal_has_logoutreq()) {
    clear_has_msg();
      ::ClientToLoginReq_LogoutReq* temp = msg_.logoutreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.logoutreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ClientToLoginReq_LogoutReq& ClientToLoginReq::_internal_logoutreq() const {
  return _internal_has_logoutreq()
      ? *msg_.logoutreq_
      : reinterpret_cast< ::ClientToLoginReq_LogoutReq&>(::_ClientToLoginReq_LogoutReq_default_instance_);
}
inline const ::ClientToLoginReq_LogoutReq& ClientToLoginReq::logoutreq() const {
  // @@protoc_insertion_point(field_get:ClientToLoginReq.logoutReq)
  return _internal_logoutreq();
}
inline ::ClientToLoginReq_LogoutReq* ClientToLoginReq::unsafe_arena_release_logoutreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ClientToLoginReq.logoutReq)
  if (_internal_has_logoutreq()) {
    clear_has_msg();
    ::ClientToLoginReq_LogoutReq* temp = msg_.logoutreq_;
    msg_.logoutreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToLoginReq::unsafe_arena_set_allocated_logoutreq(::ClientToLoginReq_LogoutReq* logoutreq) {
  clear_msg();
  if (logoutreq) {
    set_has_logoutreq();
    msg_.logoutreq_ = logoutreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientToLoginReq.logoutReq)
}
inline ::ClientToLoginReq_LogoutReq* ClientToLoginReq::_internal_mutable_logoutreq() {
  if (!_internal_has_logoutreq()) {
    clear_msg();
    set_has_logoutreq();
    msg_.logoutreq_ = CreateMaybeMessage< ::ClientToLoginReq_LogoutReq >(GetArenaForAllocation());
  }
  return msg_.logoutreq_;
}
inline ::ClientToLoginReq_LogoutReq* ClientToLoginReq::mutable_logoutreq() {
  ::ClientToLoginReq_LogoutReq* _msg = _internal_mutable_logoutreq();
  // @@protoc_insertion_point(field_mutable:ClientToLoginReq.logoutReq)
  return _msg;
}

inline bool ClientToLoginReq::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void ClientToLoginReq::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline ClientToLoginReq::MsgCase ClientToLoginReq::msg_case() const {
  return ClientToLoginReq::MsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientToLoginRes_LoginRes

// string gameServerAddr = 1;
inline void ClientToLoginRes_LoginRes::clear_gameserveraddr() {
  gameserveraddr_.ClearToEmpty();
}
inline const std::string& ClientToLoginRes_LoginRes::gameserveraddr() const {
  // @@protoc_insertion_point(field_get:ClientToLoginRes.LoginRes.gameServerAddr)
  return _internal_gameserveraddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientToLoginRes_LoginRes::set_gameserveraddr(ArgT0&& arg0, ArgT... args) {
 
 gameserveraddr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientToLoginRes.LoginRes.gameServerAddr)
}
inline std::string* ClientToLoginRes_LoginRes::mutable_gameserveraddr() {
  std::string* _s = _internal_mutable_gameserveraddr();
  // @@protoc_insertion_point(field_mutable:ClientToLoginRes.LoginRes.gameServerAddr)
  return _s;
}
inline const std::string& ClientToLoginRes_LoginRes::_internal_gameserveraddr() const {
  return gameserveraddr_.Get();
}
inline void ClientToLoginRes_LoginRes::_internal_set_gameserveraddr(const std::string& value) {
  
  gameserveraddr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClientToLoginRes_LoginRes::_internal_mutable_gameserveraddr() {
  
  return gameserveraddr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClientToLoginRes_LoginRes::release_gameserveraddr() {
  // @@protoc_insertion_point(field_release:ClientToLoginRes.LoginRes.gameServerAddr)
  return gameserveraddr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClientToLoginRes_LoginRes::set_allocated_gameserveraddr(std::string* gameserveraddr) {
  if (gameserveraddr != nullptr) {
    
  } else {
    
  }
  gameserveraddr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gameserveraddr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gameserveraddr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gameserveraddr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientToLoginRes.LoginRes.gameServerAddr)
}

// int32 gameServerPort = 2;
inline void ClientToLoginRes_LoginRes::clear_gameserverport() {
  gameserverport_ = 0;
}
inline int32_t ClientToLoginRes_LoginRes::_internal_gameserverport() const {
  return gameserverport_;
}
inline int32_t ClientToLoginRes_LoginRes::gameserverport() const {
  // @@protoc_insertion_point(field_get:ClientToLoginRes.LoginRes.gameServerPort)
  return _internal_gameserverport();
}
inline void ClientToLoginRes_LoginRes::_internal_set_gameserverport(int32_t value) {
  
  gameserverport_ = value;
}
inline void ClientToLoginRes_LoginRes::set_gameserverport(int32_t value) {
  _internal_set_gameserverport(value);
  // @@protoc_insertion_point(field_set:ClientToLoginRes.LoginRes.gameServerPort)
}

// string otp = 3;
inline void ClientToLoginRes_LoginRes::clear_otp() {
  otp_.ClearToEmpty();
}
inline const std::string& ClientToLoginRes_LoginRes::otp() const {
  // @@protoc_insertion_point(field_get:ClientToLoginRes.LoginRes.otp)
  return _internal_otp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientToLoginRes_LoginRes::set_otp(ArgT0&& arg0, ArgT... args) {
 
 otp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientToLoginRes.LoginRes.otp)
}
inline std::string* ClientToLoginRes_LoginRes::mutable_otp() {
  std::string* _s = _internal_mutable_otp();
  // @@protoc_insertion_point(field_mutable:ClientToLoginRes.LoginRes.otp)
  return _s;
}
inline const std::string& ClientToLoginRes_LoginRes::_internal_otp() const {
  return otp_.Get();
}
inline void ClientToLoginRes_LoginRes::_internal_set_otp(const std::string& value) {
  
  otp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ClientToLoginRes_LoginRes::_internal_mutable_otp() {
  
  return otp_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ClientToLoginRes_LoginRes::release_otp() {
  // @@protoc_insertion_point(field_release:ClientToLoginRes.LoginRes.otp)
  return otp_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ClientToLoginRes_LoginRes::set_allocated_otp(std::string* otp) {
  if (otp != nullptr) {
    
  } else {
    
  }
  otp_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), otp,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (otp_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    otp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientToLoginRes.LoginRes.otp)
}

// -------------------------------------------------------------------

// ClientToLoginRes_LogoutRes

// -------------------------------------------------------------------

// ClientToLoginRes

// .ClientToLoginRes.LoginServerErrorCode errorCode = 1;
inline void ClientToLoginRes::clear_errorcode() {
  errorcode_ = 0;
}
inline ::ClientToLoginRes_LoginServerErrorCode ClientToLoginRes::_internal_errorcode() const {
  return static_cast< ::ClientToLoginRes_LoginServerErrorCode >(errorcode_);
}
inline ::ClientToLoginRes_LoginServerErrorCode ClientToLoginRes::errorcode() const {
  // @@protoc_insertion_point(field_get:ClientToLoginRes.errorCode)
  return _internal_errorcode();
}
inline void ClientToLoginRes::_internal_set_errorcode(::ClientToLoginRes_LoginServerErrorCode value) {
  
  errorcode_ = value;
}
inline void ClientToLoginRes::set_errorcode(::ClientToLoginRes_LoginServerErrorCode value) {
  _internal_set_errorcode(value);
  // @@protoc_insertion_point(field_set:ClientToLoginRes.errorCode)
}

// .ClientToLoginRes.LoginRes loginRes = 2;
inline bool ClientToLoginRes::_internal_has_loginres() const {
  return msg_case() == kLoginRes;
}
inline bool ClientToLoginRes::has_loginres() const {
  return _internal_has_loginres();
}
inline void ClientToLoginRes::set_has_loginres() {
  _oneof_case_[0] = kLoginRes;
}
inline void ClientToLoginRes::clear_loginres() {
  if (_internal_has_loginres()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.loginres_;
    }
    clear_has_msg();
  }
}
inline ::ClientToLoginRes_LoginRes* ClientToLoginRes::release_loginres() {
  // @@protoc_insertion_point(field_release:ClientToLoginRes.loginRes)
  if (_internal_has_loginres()) {
    clear_has_msg();
      ::ClientToLoginRes_LoginRes* temp = msg_.loginres_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.loginres_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ClientToLoginRes_LoginRes& ClientToLoginRes::_internal_loginres() const {
  return _internal_has_loginres()
      ? *msg_.loginres_
      : reinterpret_cast< ::ClientToLoginRes_LoginRes&>(::_ClientToLoginRes_LoginRes_default_instance_);
}
inline const ::ClientToLoginRes_LoginRes& ClientToLoginRes::loginres() const {
  // @@protoc_insertion_point(field_get:ClientToLoginRes.loginRes)
  return _internal_loginres();
}
inline ::ClientToLoginRes_LoginRes* ClientToLoginRes::unsafe_arena_release_loginres() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ClientToLoginRes.loginRes)
  if (_internal_has_loginres()) {
    clear_has_msg();
    ::ClientToLoginRes_LoginRes* temp = msg_.loginres_;
    msg_.loginres_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToLoginRes::unsafe_arena_set_allocated_loginres(::ClientToLoginRes_LoginRes* loginres) {
  clear_msg();
  if (loginres) {
    set_has_loginres();
    msg_.loginres_ = loginres;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientToLoginRes.loginRes)
}
inline ::ClientToLoginRes_LoginRes* ClientToLoginRes::_internal_mutable_loginres() {
  if (!_internal_has_loginres()) {
    clear_msg();
    set_has_loginres();
    msg_.loginres_ = CreateMaybeMessage< ::ClientToLoginRes_LoginRes >(GetArenaForAllocation());
  }
  return msg_.loginres_;
}
inline ::ClientToLoginRes_LoginRes* ClientToLoginRes::mutable_loginres() {
  ::ClientToLoginRes_LoginRes* _msg = _internal_mutable_loginres();
  // @@protoc_insertion_point(field_mutable:ClientToLoginRes.loginRes)
  return _msg;
}

// .ClientToLoginRes.LogoutRes logoutRes = 3;
inline bool ClientToLoginRes::_internal_has_logoutres() const {
  return msg_case() == kLogoutRes;
}
inline bool ClientToLoginRes::has_logoutres() const {
  return _internal_has_logoutres();
}
inline void ClientToLoginRes::set_has_logoutres() {
  _oneof_case_[0] = kLogoutRes;
}
inline void ClientToLoginRes::clear_logoutres() {
  if (_internal_has_logoutres()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.logoutres_;
    }
    clear_has_msg();
  }
}
inline ::ClientToLoginRes_LogoutRes* ClientToLoginRes::release_logoutres() {
  // @@protoc_insertion_point(field_release:ClientToLoginRes.logoutRes)
  if (_internal_has_logoutres()) {
    clear_has_msg();
      ::ClientToLoginRes_LogoutRes* temp = msg_.logoutres_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.logoutres_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ClientToLoginRes_LogoutRes& ClientToLoginRes::_internal_logoutres() const {
  return _internal_has_logoutres()
      ? *msg_.logoutres_
      : reinterpret_cast< ::ClientToLoginRes_LogoutRes&>(::_ClientToLoginRes_LogoutRes_default_instance_);
}
inline const ::ClientToLoginRes_LogoutRes& ClientToLoginRes::logoutres() const {
  // @@protoc_insertion_point(field_get:ClientToLoginRes.logoutRes)
  return _internal_logoutres();
}
inline ::ClientToLoginRes_LogoutRes* ClientToLoginRes::unsafe_arena_release_logoutres() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ClientToLoginRes.logoutRes)
  if (_internal_has_logoutres()) {
    clear_has_msg();
    ::ClientToLoginRes_LogoutRes* temp = msg_.logoutres_;
    msg_.logoutres_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToLoginRes::unsafe_arena_set_allocated_logoutres(::ClientToLoginRes_LogoutRes* logoutres) {
  clear_msg();
  if (logoutres) {
    set_has_logoutres();
    msg_.logoutres_ = logoutres;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientToLoginRes.logoutRes)
}
inline ::ClientToLoginRes_LogoutRes* ClientToLoginRes::_internal_mutable_logoutres() {
  if (!_internal_has_logoutres()) {
    clear_msg();
    set_has_logoutres();
    msg_.logoutres_ = CreateMaybeMessage< ::ClientToLoginRes_LogoutRes >(GetArenaForAllocation());
  }
  return msg_.logoutres_;
}
inline ::ClientToLoginRes_LogoutRes* ClientToLoginRes::mutable_logoutres() {
  ::ClientToLoginRes_LogoutRes* _msg = _internal_mutable_logoutres();
  // @@protoc_insertion_point(field_mutable:ClientToLoginRes.logoutRes)
  return _msg;
}

inline bool ClientToLoginRes::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void ClientToLoginRes::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline ClientToLoginRes::MsgCase ClientToLoginRes::msg_case() const {
  return ClientToLoginRes::MsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientToLoginMessage_MyHome

// int32 id = 1;
inline void ClientToLoginMessage_MyHome::clear_id() {
  id_ = 0;
}
inline int32_t ClientToLoginMessage_MyHome::_internal_id() const {
  return id_;
}
inline int32_t ClientToLoginMessage_MyHome::id() const {
  // @@protoc_insertion_point(field_get:ClientToLoginMessage.MyHome.id)
  return _internal_id();
}
inline void ClientToLoginMessage_MyHome::_internal_set_id(int32_t value) {
  
  id_ = value;
}
inline void ClientToLoginMessage_MyHome::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:ClientToLoginMessage.MyHome.id)
}

// repeated .MyHomeObjectSlotInfo slotInfo = 2;
inline int ClientToLoginMessage_MyHome::_internal_slotinfo_size() const {
  return slotinfo_.size();
}
inline int ClientToLoginMessage_MyHome::slotinfo_size() const {
  return _internal_slotinfo_size();
}
inline void ClientToLoginMessage_MyHome::clear_slotinfo() {
  slotinfo_.Clear();
}
inline ::MyHomeObjectSlotInfo* ClientToLoginMessage_MyHome::mutable_slotinfo(int index) {
  // @@protoc_insertion_point(field_mutable:ClientToLoginMessage.MyHome.slotInfo)
  return slotinfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MyHomeObjectSlotInfo >*
ClientToLoginMessage_MyHome::mutable_slotinfo() {
  // @@protoc_insertion_point(field_mutable_list:ClientToLoginMessage.MyHome.slotInfo)
  return &slotinfo_;
}
inline const ::MyHomeObjectSlotInfo& ClientToLoginMessage_MyHome::_internal_slotinfo(int index) const {
  return slotinfo_.Get(index);
}
inline const ::MyHomeObjectSlotInfo& ClientToLoginMessage_MyHome::slotinfo(int index) const {
  // @@protoc_insertion_point(field_get:ClientToLoginMessage.MyHome.slotInfo)
  return _internal_slotinfo(index);
}
inline ::MyHomeObjectSlotInfo* ClientToLoginMessage_MyHome::_internal_add_slotinfo() {
  return slotinfo_.Add();
}
inline ::MyHomeObjectSlotInfo* ClientToLoginMessage_MyHome::add_slotinfo() {
  ::MyHomeObjectSlotInfo* _add = _internal_add_slotinfo();
  // @@protoc_insertion_point(field_add:ClientToLoginMessage.MyHome.slotInfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MyHomeObjectSlotInfo >&
ClientToLoginMessage_MyHome::slotinfo() const {
  // @@protoc_insertion_point(field_list:ClientToLoginMessage.MyHome.slotInfo)
  return slotinfo_;
}

// -------------------------------------------------------------------

// ClientToLoginMessage

// .ClientToLoginMessage.MyHome myHome = 1;
inline bool ClientToLoginMessage::_internal_has_myhome() const {
  return msg_case() == kMyHome;
}
inline bool ClientToLoginMessage::has_myhome() const {
  return _internal_has_myhome();
}
inline void ClientToLoginMessage::set_has_myhome() {
  _oneof_case_[0] = kMyHome;
}
inline void ClientToLoginMessage::clear_myhome() {
  if (_internal_has_myhome()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.myhome_;
    }
    clear_has_msg();
  }
}
inline ::ClientToLoginMessage_MyHome* ClientToLoginMessage::release_myhome() {
  // @@protoc_insertion_point(field_release:ClientToLoginMessage.myHome)
  if (_internal_has_myhome()) {
    clear_has_msg();
      ::ClientToLoginMessage_MyHome* temp = msg_.myhome_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.myhome_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ClientToLoginMessage_MyHome& ClientToLoginMessage::_internal_myhome() const {
  return _internal_has_myhome()
      ? *msg_.myhome_
      : reinterpret_cast< ::ClientToLoginMessage_MyHome&>(::_ClientToLoginMessage_MyHome_default_instance_);
}
inline const ::ClientToLoginMessage_MyHome& ClientToLoginMessage::myhome() const {
  // @@protoc_insertion_point(field_get:ClientToLoginMessage.myHome)
  return _internal_myhome();
}
inline ::ClientToLoginMessage_MyHome* ClientToLoginMessage::unsafe_arena_release_myhome() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ClientToLoginMessage.myHome)
  if (_internal_has_myhome()) {
    clear_has_msg();
    ::ClientToLoginMessage_MyHome* temp = msg_.myhome_;
    msg_.myhome_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToLoginMessage::unsafe_arena_set_allocated_myhome(::ClientToLoginMessage_MyHome* myhome) {
  clear_msg();
  if (myhome) {
    set_has_myhome();
    msg_.myhome_ = myhome;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientToLoginMessage.myHome)
}
inline ::ClientToLoginMessage_MyHome* ClientToLoginMessage::_internal_mutable_myhome() {
  if (!_internal_has_myhome()) {
    clear_msg();
    set_has_myhome();
    msg_.myhome_ = CreateMaybeMessage< ::ClientToLoginMessage_MyHome >(GetArenaForAllocation());
  }
  return msg_.myhome_;
}
inline ::ClientToLoginMessage_MyHome* ClientToLoginMessage::mutable_myhome() {
  ::ClientToLoginMessage_MyHome* _msg = _internal_mutable_myhome();
  // @@protoc_insertion_point(field_mutable:ClientToLoginMessage.myHome)
  return _msg;
}

inline bool ClientToLoginMessage::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void ClientToLoginMessage::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline ClientToLoginMessage::MsgCase ClientToLoginMessage::msg_case() const {
  return ClientToLoginMessage::MsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClientToLogin

// .ClientToLoginReq request = 1;
inline bool ClientToLogin::_internal_has_request() const {
  return msg_case() == kRequest;
}
inline bool ClientToLogin::has_request() const {
  return _internal_has_request();
}
inline void ClientToLogin::set_has_request() {
  _oneof_case_[0] = kRequest;
}
inline void ClientToLogin::clear_request() {
  if (_internal_has_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.request_;
    }
    clear_has_msg();
  }
}
inline ::ClientToLoginReq* ClientToLogin::release_request() {
  // @@protoc_insertion_point(field_release:ClientToLogin.request)
  if (_internal_has_request()) {
    clear_has_msg();
      ::ClientToLoginReq* temp = msg_.request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ClientToLoginReq& ClientToLogin::_internal_request() const {
  return _internal_has_request()
      ? *msg_.request_
      : reinterpret_cast< ::ClientToLoginReq&>(::_ClientToLoginReq_default_instance_);
}
inline const ::ClientToLoginReq& ClientToLogin::request() const {
  // @@protoc_insertion_point(field_get:ClientToLogin.request)
  return _internal_request();
}
inline ::ClientToLoginReq* ClientToLogin::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ClientToLogin.request)
  if (_internal_has_request()) {
    clear_has_msg();
    ::ClientToLoginReq* temp = msg_.request_;
    msg_.request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToLogin::unsafe_arena_set_allocated_request(::ClientToLoginReq* request) {
  clear_msg();
  if (request) {
    set_has_request();
    msg_.request_ = request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientToLogin.request)
}
inline ::ClientToLoginReq* ClientToLogin::_internal_mutable_request() {
  if (!_internal_has_request()) {
    clear_msg();
    set_has_request();
    msg_.request_ = CreateMaybeMessage< ::ClientToLoginReq >(GetArenaForAllocation());
  }
  return msg_.request_;
}
inline ::ClientToLoginReq* ClientToLogin::mutable_request() {
  ::ClientToLoginReq* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:ClientToLogin.request)
  return _msg;
}

// .ClientToLoginRes response = 2;
inline bool ClientToLogin::_internal_has_response() const {
  return msg_case() == kResponse;
}
inline bool ClientToLogin::has_response() const {
  return _internal_has_response();
}
inline void ClientToLogin::set_has_response() {
  _oneof_case_[0] = kResponse;
}
inline void ClientToLogin::clear_response() {
  if (_internal_has_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.response_;
    }
    clear_has_msg();
  }
}
inline ::ClientToLoginRes* ClientToLogin::release_response() {
  // @@protoc_insertion_point(field_release:ClientToLogin.response)
  if (_internal_has_response()) {
    clear_has_msg();
      ::ClientToLoginRes* temp = msg_.response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ClientToLoginRes& ClientToLogin::_internal_response() const {
  return _internal_has_response()
      ? *msg_.response_
      : reinterpret_cast< ::ClientToLoginRes&>(::_ClientToLoginRes_default_instance_);
}
inline const ::ClientToLoginRes& ClientToLogin::response() const {
  // @@protoc_insertion_point(field_get:ClientToLogin.response)
  return _internal_response();
}
inline ::ClientToLoginRes* ClientToLogin::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ClientToLogin.response)
  if (_internal_has_response()) {
    clear_has_msg();
    ::ClientToLoginRes* temp = msg_.response_;
    msg_.response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToLogin::unsafe_arena_set_allocated_response(::ClientToLoginRes* response) {
  clear_msg();
  if (response) {
    set_has_response();
    msg_.response_ = response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientToLogin.response)
}
inline ::ClientToLoginRes* ClientToLogin::_internal_mutable_response() {
  if (!_internal_has_response()) {
    clear_msg();
    set_has_response();
    msg_.response_ = CreateMaybeMessage< ::ClientToLoginRes >(GetArenaForAllocation());
  }
  return msg_.response_;
}
inline ::ClientToLoginRes* ClientToLogin::mutable_response() {
  ::ClientToLoginRes* _msg = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:ClientToLogin.response)
  return _msg;
}

// .ClientToLoginMessage message = 3;
inline bool ClientToLogin::_internal_has_message() const {
  return msg_case() == kMessage;
}
inline bool ClientToLogin::has_message() const {
  return _internal_has_message();
}
inline void ClientToLogin::set_has_message() {
  _oneof_case_[0] = kMessage;
}
inline void ClientToLogin::clear_message() {
  if (_internal_has_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.message_;
    }
    clear_has_msg();
  }
}
inline ::ClientToLoginMessage* ClientToLogin::release_message() {
  // @@protoc_insertion_point(field_release:ClientToLogin.message)
  if (_internal_has_message()) {
    clear_has_msg();
      ::ClientToLoginMessage* temp = msg_.message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ClientToLoginMessage& ClientToLogin::_internal_message() const {
  return _internal_has_message()
      ? *msg_.message_
      : reinterpret_cast< ::ClientToLoginMessage&>(::_ClientToLoginMessage_default_instance_);
}
inline const ::ClientToLoginMessage& ClientToLogin::message() const {
  // @@protoc_insertion_point(field_get:ClientToLogin.message)
  return _internal_message();
}
inline ::ClientToLoginMessage* ClientToLogin::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ClientToLogin.message)
  if (_internal_has_message()) {
    clear_has_msg();
    ::ClientToLoginMessage* temp = msg_.message_;
    msg_.message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClientToLogin::unsafe_arena_set_allocated_message(::ClientToLoginMessage* message) {
  clear_msg();
  if (message) {
    set_has_message();
    msg_.message_ = message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientToLogin.message)
}
inline ::ClientToLoginMessage* ClientToLogin::_internal_mutable_message() {
  if (!_internal_has_message()) {
    clear_msg();
    set_has_message();
    msg_.message_ = CreateMaybeMessage< ::ClientToLoginMessage >(GetArenaForAllocation());
  }
  return msg_.message_;
}
inline ::ClientToLoginMessage* ClientToLogin::mutable_message() {
  ::ClientToLoginMessage* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ClientToLogin.message)
  return _msg;
}

inline bool ClientToLogin::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void ClientToLogin::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline ClientToLogin::MsgCase ClientToLogin::msg_case() const {
  return ClientToLogin::MsgCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ClientToLoginRes_LoginServerErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ClientToLoginRes_LoginServerErrorCode>() {
  return ::ClientToLoginRes_LoginServerErrorCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tutorial_2ehierarchy_2eproto
