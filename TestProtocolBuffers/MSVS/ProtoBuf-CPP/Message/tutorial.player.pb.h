// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tutorial.player.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tutorial_2eplayer_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tutorial_2eplayer_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tutorial_2eplayer_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tutorial_2eplayer_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tutorial_2eplayer_2eproto;
namespace tutorial {
class Player;
struct PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class Player_Bag;
struct Player_BagDefaultTypeInternal;
extern Player_BagDefaultTypeInternal _Player_Bag_default_instance_;
class Player_Box;
struct Player_BoxDefaultTypeInternal;
extern Player_BoxDefaultTypeInternal _Player_Box_default_instance_;
class Player_Box_ItemsEntry_DoNotUse;
struct Player_Box_ItemsEntry_DoNotUseDefaultTypeInternal;
extern Player_Box_ItemsEntry_DoNotUseDefaultTypeInternal _Player_Box_ItemsEntry_DoNotUse_default_instance_;
class Player_Item;
struct Player_ItemDefaultTypeInternal;
extern Player_ItemDefaultTypeInternal _Player_Item_default_instance_;
class Player_ItemsEntry_DoNotUse;
struct Player_ItemsEntry_DoNotUseDefaultTypeInternal;
extern Player_ItemsEntry_DoNotUseDefaultTypeInternal _Player_ItemsEntry_DoNotUse_default_instance_;
class Player_MobilePhone;
struct Player_MobilePhoneDefaultTypeInternal;
extern Player_MobilePhoneDefaultTypeInternal _Player_MobilePhone_default_instance_;
class Player_MyTrunk;
struct Player_MyTrunkDefaultTypeInternal;
extern Player_MyTrunkDefaultTypeInternal _Player_MyTrunk_default_instance_;
class Player_MyTrunk_BoxsEntry_DoNotUse;
struct Player_MyTrunk_BoxsEntry_DoNotUseDefaultTypeInternal;
extern Player_MyTrunk_BoxsEntry_DoNotUseDefaultTypeInternal _Player_MyTrunk_BoxsEntry_DoNotUse_default_instance_;
class Player_MyTrunksEntry_DoNotUse;
struct Player_MyTrunksEntry_DoNotUseDefaultTypeInternal;
extern Player_MyTrunksEntry_DoNotUseDefaultTypeInternal _Player_MyTrunksEntry_DoNotUse_default_instance_;
class Player_PhoneNumber;
struct Player_PhoneNumberDefaultTypeInternal;
extern Player_PhoneNumberDefaultTypeInternal _Player_PhoneNumber_default_instance_;
class Player_Wallet;
struct Player_WalletDefaultTypeInternal;
extern Player_WalletDefaultTypeInternal _Player_Wallet_default_instance_;
class Player_Watch;
struct Player_WatchDefaultTypeInternal;
extern Player_WatchDefaultTypeInternal _Player_Watch_default_instance_;
}  // namespace tutorial
PROTOBUF_NAMESPACE_OPEN
template<> ::tutorial::Player* Arena::CreateMaybeMessage<::tutorial::Player>(Arena*);
template<> ::tutorial::Player_Bag* Arena::CreateMaybeMessage<::tutorial::Player_Bag>(Arena*);
template<> ::tutorial::Player_Box* Arena::CreateMaybeMessage<::tutorial::Player_Box>(Arena*);
template<> ::tutorial::Player_Box_ItemsEntry_DoNotUse* Arena::CreateMaybeMessage<::tutorial::Player_Box_ItemsEntry_DoNotUse>(Arena*);
template<> ::tutorial::Player_Item* Arena::CreateMaybeMessage<::tutorial::Player_Item>(Arena*);
template<> ::tutorial::Player_ItemsEntry_DoNotUse* Arena::CreateMaybeMessage<::tutorial::Player_ItemsEntry_DoNotUse>(Arena*);
template<> ::tutorial::Player_MobilePhone* Arena::CreateMaybeMessage<::tutorial::Player_MobilePhone>(Arena*);
template<> ::tutorial::Player_MyTrunk* Arena::CreateMaybeMessage<::tutorial::Player_MyTrunk>(Arena*);
template<> ::tutorial::Player_MyTrunk_BoxsEntry_DoNotUse* Arena::CreateMaybeMessage<::tutorial::Player_MyTrunk_BoxsEntry_DoNotUse>(Arena*);
template<> ::tutorial::Player_MyTrunksEntry_DoNotUse* Arena::CreateMaybeMessage<::tutorial::Player_MyTrunksEntry_DoNotUse>(Arena*);
template<> ::tutorial::Player_PhoneNumber* Arena::CreateMaybeMessage<::tutorial::Player_PhoneNumber>(Arena*);
template<> ::tutorial::Player_Wallet* Arena::CreateMaybeMessage<::tutorial::Player_Wallet>(Arena*);
template<> ::tutorial::Player_Watch* Arena::CreateMaybeMessage<::tutorial::Player_Watch>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tutorial {

enum Player_PhoneType : int {
  Player_PhoneType_MOBILE = 0,
  Player_PhoneType_HOME = 1,
  Player_PhoneType_WORK = 2,
  Player_PhoneType_Player_PhoneType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Player_PhoneType_Player_PhoneType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Player_PhoneType_IsValid(int value);
constexpr Player_PhoneType Player_PhoneType_PhoneType_MIN = Player_PhoneType_MOBILE;
constexpr Player_PhoneType Player_PhoneType_PhoneType_MAX = Player_PhoneType_WORK;
constexpr int Player_PhoneType_PhoneType_ARRAYSIZE = Player_PhoneType_PhoneType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Player_PhoneType_descriptor();
template<typename T>
inline const std::string& Player_PhoneType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Player_PhoneType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Player_PhoneType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Player_PhoneType_descriptor(), enum_t_value);
}
inline bool Player_PhoneType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Player_PhoneType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Player_PhoneType>(
    Player_PhoneType_descriptor(), name, value);
}
// ===================================================================

class Player_PhoneNumber final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.Player.PhoneNumber) */ {
 public:
  inline Player_PhoneNumber() : Player_PhoneNumber(nullptr) {}
  ~Player_PhoneNumber() override;
  explicit constexpr Player_PhoneNumber(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player_PhoneNumber(const Player_PhoneNumber& from);
  Player_PhoneNumber(Player_PhoneNumber&& from) noexcept
    : Player_PhoneNumber() {
    *this = ::std::move(from);
  }

  inline Player_PhoneNumber& operator=(const Player_PhoneNumber& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player_PhoneNumber& operator=(Player_PhoneNumber&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player_PhoneNumber& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player_PhoneNumber* internal_default_instance() {
    return reinterpret_cast<const Player_PhoneNumber*>(
               &_Player_PhoneNumber_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Player_PhoneNumber& a, Player_PhoneNumber& b) {
    a.Swap(&b);
  }
  inline void Swap(Player_PhoneNumber* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player_PhoneNumber* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player_PhoneNumber* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player_PhoneNumber>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player_PhoneNumber& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Player_PhoneNumber& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player_PhoneNumber* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.Player.PhoneNumber";
  }
  protected:
  explicit Player_PhoneNumber(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string number = 1;
  void clear_number();
  const std::string& number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_number();
  PROTOBUF_NODISCARD std::string* release_number();
  void set_allocated_number(std::string* number);
  private:
  const std::string& _internal_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_number(const std::string& value);
  std::string* _internal_mutable_number();
  public:

  // .tutorial.Player.PhoneType type = 2;
  void clear_type();
  ::tutorial::Player_PhoneType type() const;
  void set_type(::tutorial::Player_PhoneType value);
  private:
  ::tutorial::Player_PhoneType _internal_type() const;
  void _internal_set_type(::tutorial::Player_PhoneType value);
  public:

  // @@protoc_insertion_point(class_scope:tutorial.Player.PhoneNumber)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr number_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tutorial_2eplayer_2eproto;
};
// -------------------------------------------------------------------

class Player_Item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.Player.Item) */ {
 public:
  inline Player_Item() : Player_Item(nullptr) {}
  ~Player_Item() override;
  explicit constexpr Player_Item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player_Item(const Player_Item& from);
  Player_Item(Player_Item&& from) noexcept
    : Player_Item() {
    *this = ::std::move(from);
  }

  inline Player_Item& operator=(const Player_Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player_Item& operator=(Player_Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player_Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player_Item* internal_default_instance() {
    return reinterpret_cast<const Player_Item*>(
               &_Player_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Player_Item& a, Player_Item& b) {
    a.Swap(&b);
  }
  inline void Swap(Player_Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player_Item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player_Item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player_Item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player_Item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Player_Item& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player_Item* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.Player.Item";
  }
  protected:
  explicit Player_Item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kItemTidFieldNumber = 2,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // int32 itemTid = 2;
  void clear_itemtid();
  int32_t itemtid() const;
  void set_itemtid(int32_t value);
  private:
  int32_t _internal_itemtid() const;
  void _internal_set_itemtid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tutorial.Player.Item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t id_;
  int32_t itemtid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tutorial_2eplayer_2eproto;
};
// -------------------------------------------------------------------

class Player_ItemsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Player_ItemsEntry_DoNotUse, 
    uint64_t, ::tutorial::Player_Item,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Player_ItemsEntry_DoNotUse, 
    uint64_t, ::tutorial::Player_Item,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Player_ItemsEntry_DoNotUse();
  explicit constexpr Player_ItemsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Player_ItemsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Player_ItemsEntry_DoNotUse& other);
  static const Player_ItemsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Player_ItemsEntry_DoNotUse*>(&_Player_ItemsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Player_MobilePhone final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.Player.MobilePhone) */ {
 public:
  inline Player_MobilePhone() : Player_MobilePhone(nullptr) {}
  ~Player_MobilePhone() override;
  explicit constexpr Player_MobilePhone(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player_MobilePhone(const Player_MobilePhone& from);
  Player_MobilePhone(Player_MobilePhone&& from) noexcept
    : Player_MobilePhone() {
    *this = ::std::move(from);
  }

  inline Player_MobilePhone& operator=(const Player_MobilePhone& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player_MobilePhone& operator=(Player_MobilePhone&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player_MobilePhone& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player_MobilePhone* internal_default_instance() {
    return reinterpret_cast<const Player_MobilePhone*>(
               &_Player_MobilePhone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Player_MobilePhone& a, Player_MobilePhone& b) {
    a.Swap(&b);
  }
  inline void Swap(Player_MobilePhone* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player_MobilePhone* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player_MobilePhone* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player_MobilePhone>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player_MobilePhone& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Player_MobilePhone& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player_MobilePhone* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.Player.MobilePhone";
  }
  protected:
  explicit Player_MobilePhone(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
  };
  // string device = 1;
  void clear_device();
  const std::string& device() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* device);
  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(const std::string& value);
  std::string* _internal_mutable_device();
  public:

  // @@protoc_insertion_point(class_scope:tutorial.Player.MobilePhone)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tutorial_2eplayer_2eproto;
};
// -------------------------------------------------------------------

class Player_Watch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.Player.Watch) */ {
 public:
  inline Player_Watch() : Player_Watch(nullptr) {}
  ~Player_Watch() override;
  explicit constexpr Player_Watch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player_Watch(const Player_Watch& from);
  Player_Watch(Player_Watch&& from) noexcept
    : Player_Watch() {
    *this = ::std::move(from);
  }

  inline Player_Watch& operator=(const Player_Watch& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player_Watch& operator=(Player_Watch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player_Watch& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player_Watch* internal_default_instance() {
    return reinterpret_cast<const Player_Watch*>(
               &_Player_Watch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Player_Watch& a, Player_Watch& b) {
    a.Swap(&b);
  }
  inline void Swap(Player_Watch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player_Watch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player_Watch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player_Watch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player_Watch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Player_Watch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player_Watch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.Player.Watch";
  }
  protected:
  explicit Player_Watch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
  };
  // string device = 1;
  void clear_device();
  const std::string& device() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* device);
  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(const std::string& value);
  std::string* _internal_mutable_device();
  public:

  // @@protoc_insertion_point(class_scope:tutorial.Player.Watch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tutorial_2eplayer_2eproto;
};
// -------------------------------------------------------------------

class Player_Wallet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.Player.Wallet) */ {
 public:
  inline Player_Wallet() : Player_Wallet(nullptr) {}
  ~Player_Wallet() override;
  explicit constexpr Player_Wallet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player_Wallet(const Player_Wallet& from);
  Player_Wallet(Player_Wallet&& from) noexcept
    : Player_Wallet() {
    *this = ::std::move(from);
  }

  inline Player_Wallet& operator=(const Player_Wallet& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player_Wallet& operator=(Player_Wallet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player_Wallet& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player_Wallet* internal_default_instance() {
    return reinterpret_cast<const Player_Wallet*>(
               &_Player_Wallet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Player_Wallet& a, Player_Wallet& b) {
    a.Swap(&b);
  }
  inline void Swap(Player_Wallet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player_Wallet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player_Wallet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player_Wallet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player_Wallet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Player_Wallet& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player_Wallet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.Player.Wallet";
  }
  protected:
  explicit Player_Wallet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .tutorial.Player.Item items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::tutorial::Player_Item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_Item >*
      mutable_items();
  private:
  const ::tutorial::Player_Item& _internal_items(int index) const;
  ::tutorial::Player_Item* _internal_add_items();
  public:
  const ::tutorial::Player_Item& items(int index) const;
  ::tutorial::Player_Item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_Item >&
      items() const;

  // @@protoc_insertion_point(class_scope:tutorial.Player.Wallet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_Item > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tutorial_2eplayer_2eproto;
};
// -------------------------------------------------------------------

class Player_Bag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.Player.Bag) */ {
 public:
  inline Player_Bag() : Player_Bag(nullptr) {}
  ~Player_Bag() override;
  explicit constexpr Player_Bag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player_Bag(const Player_Bag& from);
  Player_Bag(Player_Bag&& from) noexcept
    : Player_Bag() {
    *this = ::std::move(from);
  }

  inline Player_Bag& operator=(const Player_Bag& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player_Bag& operator=(Player_Bag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player_Bag& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player_Bag* internal_default_instance() {
    return reinterpret_cast<const Player_Bag*>(
               &_Player_Bag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Player_Bag& a, Player_Bag& b) {
    a.Swap(&b);
  }
  inline void Swap(Player_Bag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player_Bag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player_Bag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player_Bag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player_Bag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Player_Bag& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player_Bag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.Player.Bag";
  }
  protected:
  explicit Player_Bag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWalletsFieldNumber = 1,
  };
  // repeated .tutorial.Player.Wallet wallets = 1;
  int wallets_size() const;
  private:
  int _internal_wallets_size() const;
  public:
  void clear_wallets();
  ::tutorial::Player_Wallet* mutable_wallets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_Wallet >*
      mutable_wallets();
  private:
  const ::tutorial::Player_Wallet& _internal_wallets(int index) const;
  ::tutorial::Player_Wallet* _internal_add_wallets();
  public:
  const ::tutorial::Player_Wallet& wallets(int index) const;
  ::tutorial::Player_Wallet* add_wallets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_Wallet >&
      wallets() const;

  // @@protoc_insertion_point(class_scope:tutorial.Player.Bag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_Wallet > wallets_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tutorial_2eplayer_2eproto;
};
// -------------------------------------------------------------------

class Player_Box_ItemsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Player_Box_ItemsEntry_DoNotUse, 
    uint64_t, ::tutorial::Player_Item,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Player_Box_ItemsEntry_DoNotUse, 
    uint64_t, ::tutorial::Player_Item,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Player_Box_ItemsEntry_DoNotUse();
  explicit constexpr Player_Box_ItemsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Player_Box_ItemsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Player_Box_ItemsEntry_DoNotUse& other);
  static const Player_Box_ItemsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Player_Box_ItemsEntry_DoNotUse*>(&_Player_Box_ItemsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Player_Box final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.Player.Box) */ {
 public:
  inline Player_Box() : Player_Box(nullptr) {}
  ~Player_Box() override;
  explicit constexpr Player_Box(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player_Box(const Player_Box& from);
  Player_Box(Player_Box&& from) noexcept
    : Player_Box() {
    *this = ::std::move(from);
  }

  inline Player_Box& operator=(const Player_Box& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player_Box& operator=(Player_Box&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player_Box& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player_Box* internal_default_instance() {
    return reinterpret_cast<const Player_Box*>(
               &_Player_Box_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Player_Box& a, Player_Box& b) {
    a.Swap(&b);
  }
  inline void Swap(Player_Box* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player_Box* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player_Box* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player_Box>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player_Box& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Player_Box& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player_Box* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.Player.Box";
  }
  protected:
  explicit Player_Box(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // map<uint64, .tutorial.Player.Item> items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Item >&
      _internal_items() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Item >*
      _internal_mutable_items();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Item >&
      items() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Item >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:tutorial.Player.Box)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Player_Box_ItemsEntry_DoNotUse,
      uint64_t, ::tutorial::Player_Item,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tutorial_2eplayer_2eproto;
};
// -------------------------------------------------------------------

class Player_MyTrunk_BoxsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Player_MyTrunk_BoxsEntry_DoNotUse, 
    uint64_t, ::tutorial::Player_Box,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Player_MyTrunk_BoxsEntry_DoNotUse, 
    uint64_t, ::tutorial::Player_Box,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Player_MyTrunk_BoxsEntry_DoNotUse();
  explicit constexpr Player_MyTrunk_BoxsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Player_MyTrunk_BoxsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Player_MyTrunk_BoxsEntry_DoNotUse& other);
  static const Player_MyTrunk_BoxsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Player_MyTrunk_BoxsEntry_DoNotUse*>(&_Player_MyTrunk_BoxsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Player_MyTrunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.Player.MyTrunk) */ {
 public:
  inline Player_MyTrunk() : Player_MyTrunk(nullptr) {}
  ~Player_MyTrunk() override;
  explicit constexpr Player_MyTrunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player_MyTrunk(const Player_MyTrunk& from);
  Player_MyTrunk(Player_MyTrunk&& from) noexcept
    : Player_MyTrunk() {
    *this = ::std::move(from);
  }

  inline Player_MyTrunk& operator=(const Player_MyTrunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player_MyTrunk& operator=(Player_MyTrunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player_MyTrunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player_MyTrunk* internal_default_instance() {
    return reinterpret_cast<const Player_MyTrunk*>(
               &_Player_MyTrunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Player_MyTrunk& a, Player_MyTrunk& b) {
    a.Swap(&b);
  }
  inline void Swap(Player_MyTrunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player_MyTrunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player_MyTrunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player_MyTrunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player_MyTrunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Player_MyTrunk& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player_MyTrunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.Player.MyTrunk";
  }
  protected:
  explicit Player_MyTrunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kBoxsFieldNumber = 1,
  };
  // map<uint64, .tutorial.Player.Box> boxs = 1;
  int boxs_size() const;
  private:
  int _internal_boxs_size() const;
  public:
  void clear_boxs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Box >&
      _internal_boxs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Box >*
      _internal_mutable_boxs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Box >&
      boxs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Box >*
      mutable_boxs();

  // @@protoc_insertion_point(class_scope:tutorial.Player.MyTrunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Player_MyTrunk_BoxsEntry_DoNotUse,
      uint64_t, ::tutorial::Player_Box,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> boxs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tutorial_2eplayer_2eproto;
};
// -------------------------------------------------------------------

class Player_MyTrunksEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Player_MyTrunksEntry_DoNotUse, 
    uint64_t, ::tutorial::Player_MyTrunk,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Player_MyTrunksEntry_DoNotUse, 
    uint64_t, ::tutorial::Player_MyTrunk,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Player_MyTrunksEntry_DoNotUse();
  explicit constexpr Player_MyTrunksEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Player_MyTrunksEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Player_MyTrunksEntry_DoNotUse& other);
  static const Player_MyTrunksEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Player_MyTrunksEntry_DoNotUse*>(&_Player_MyTrunksEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  ~Player() override;
  explicit constexpr Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kMobilePhone = 6,
    kWatch = 7,
    MSG_NOT_SET = 0,
  };

  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Player& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.Player";
  }
  protected:
  explicit Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Player_PhoneNumber PhoneNumber;
  typedef Player_Item Item;
  typedef Player_MobilePhone MobilePhone;
  typedef Player_Watch Watch;
  typedef Player_Wallet Wallet;
  typedef Player_Bag Bag;
  typedef Player_Box Box;
  typedef Player_MyTrunk MyTrunk;

  typedef Player_PhoneType PhoneType;
  static constexpr PhoneType MOBILE =
    Player_PhoneType_MOBILE;
  static constexpr PhoneType HOME =
    Player_PhoneType_HOME;
  static constexpr PhoneType WORK =
    Player_PhoneType_WORK;
  static inline bool PhoneType_IsValid(int value) {
    return Player_PhoneType_IsValid(value);
  }
  static constexpr PhoneType PhoneType_MIN =
    Player_PhoneType_PhoneType_MIN;
  static constexpr PhoneType PhoneType_MAX =
    Player_PhoneType_PhoneType_MAX;
  static constexpr int PhoneType_ARRAYSIZE =
    Player_PhoneType_PhoneType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PhoneType_descriptor() {
    return Player_PhoneType_descriptor();
  }
  template<typename T>
  static inline const std::string& PhoneType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PhoneType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PhoneType_Name.");
    return Player_PhoneType_Name(enum_t_value);
  }
  static inline bool PhoneType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PhoneType* value) {
    return Player_PhoneType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPhonesFieldNumber = 4,
    kItemsFieldNumber = 5,
    kBagsFieldNumber = 8,
    kMyTrunksFieldNumber = 9,
    kNameFieldNumber = 2,
    kEmailFieldNumber = 3,
    kIdFieldNumber = 1,
    kMobilePhoneFieldNumber = 6,
    kWatchFieldNumber = 7,
  };
  // repeated .tutorial.Player.PhoneNumber phones = 4;
  int phones_size() const;
  private:
  int _internal_phones_size() const;
  public:
  void clear_phones();
  ::tutorial::Player_PhoneNumber* mutable_phones(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_PhoneNumber >*
      mutable_phones();
  private:
  const ::tutorial::Player_PhoneNumber& _internal_phones(int index) const;
  ::tutorial::Player_PhoneNumber* _internal_add_phones();
  public:
  const ::tutorial::Player_PhoneNumber& phones(int index) const;
  ::tutorial::Player_PhoneNumber* add_phones();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_PhoneNumber >&
      phones() const;

  // map<uint64, .tutorial.Player.Item> items = 5;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Item >&
      _internal_items() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Item >*
      _internal_mutable_items();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Item >&
      items() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Item >*
      mutable_items();

  // repeated .tutorial.Player.Bag bags = 8;
  int bags_size() const;
  private:
  int _internal_bags_size() const;
  public:
  void clear_bags();
  ::tutorial::Player_Bag* mutable_bags(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_Bag >*
      mutable_bags();
  private:
  const ::tutorial::Player_Bag& _internal_bags(int index) const;
  ::tutorial::Player_Bag* _internal_add_bags();
  public:
  const ::tutorial::Player_Bag& bags(int index) const;
  ::tutorial::Player_Bag* add_bags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_Bag >&
      bags() const;

  // map<uint64, .tutorial.Player.MyTrunk> myTrunks = 9;
  int mytrunks_size() const;
  private:
  int _internal_mytrunks_size() const;
  public:
  void clear_mytrunks();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_MyTrunk >&
      _internal_mytrunks() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_MyTrunk >*
      _internal_mutable_mytrunks();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_MyTrunk >&
      mytrunks() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_MyTrunk >*
      mutable_mytrunks();

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string email = 3;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // .tutorial.Player.MobilePhone mobilePhone = 6;
  bool has_mobilephone() const;
  private:
  bool _internal_has_mobilephone() const;
  public:
  void clear_mobilephone();
  const ::tutorial::Player_MobilePhone& mobilephone() const;
  PROTOBUF_NODISCARD ::tutorial::Player_MobilePhone* release_mobilephone();
  ::tutorial::Player_MobilePhone* mutable_mobilephone();
  void set_allocated_mobilephone(::tutorial::Player_MobilePhone* mobilephone);
  private:
  const ::tutorial::Player_MobilePhone& _internal_mobilephone() const;
  ::tutorial::Player_MobilePhone* _internal_mutable_mobilephone();
  public:
  void unsafe_arena_set_allocated_mobilephone(
      ::tutorial::Player_MobilePhone* mobilephone);
  ::tutorial::Player_MobilePhone* unsafe_arena_release_mobilephone();

  // .tutorial.Player.Watch watch = 7;
  bool has_watch() const;
  private:
  bool _internal_has_watch() const;
  public:
  void clear_watch();
  const ::tutorial::Player_Watch& watch() const;
  PROTOBUF_NODISCARD ::tutorial::Player_Watch* release_watch();
  ::tutorial::Player_Watch* mutable_watch();
  void set_allocated_watch(::tutorial::Player_Watch* watch);
  private:
  const ::tutorial::Player_Watch& _internal_watch() const;
  ::tutorial::Player_Watch* _internal_mutable_watch();
  public:
  void unsafe_arena_set_allocated_watch(
      ::tutorial::Player_Watch* watch);
  ::tutorial::Player_Watch* unsafe_arena_release_watch();

  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:tutorial.Player)
 private:
  class _Internal;
  void set_has_mobilephone();
  void set_has_watch();

  inline bool has_msg() const;
  inline void clear_has_msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_PhoneNumber > phones_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Player_ItemsEntry_DoNotUse,
      uint64_t, ::tutorial::Player_Item,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> items_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_Bag > bags_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Player_MyTrunksEntry_DoNotUse,
      uint64_t, ::tutorial::Player_MyTrunk,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> mytrunks_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  uint64_t id_;
  union MsgUnion {
    constexpr MsgUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::tutorial::Player_MobilePhone* mobilephone_;
    ::tutorial::Player_Watch* watch_;
  } msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_tutorial_2eplayer_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Player_PhoneNumber

// string number = 1;
inline void Player_PhoneNumber::clear_number() {
  number_.ClearToEmpty();
}
inline const std::string& Player_PhoneNumber::number() const {
  // @@protoc_insertion_point(field_get:tutorial.Player.PhoneNumber.number)
  return _internal_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Player_PhoneNumber::set_number(ArgT0&& arg0, ArgT... args) {
 
 number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tutorial.Player.PhoneNumber.number)
}
inline std::string* Player_PhoneNumber::mutable_number() {
  std::string* _s = _internal_mutable_number();
  // @@protoc_insertion_point(field_mutable:tutorial.Player.PhoneNumber.number)
  return _s;
}
inline const std::string& Player_PhoneNumber::_internal_number() const {
  return number_.Get();
}
inline void Player_PhoneNumber::_internal_set_number(const std::string& value) {
  
  number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Player_PhoneNumber::_internal_mutable_number() {
  
  return number_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Player_PhoneNumber::release_number() {
  // @@protoc_insertion_point(field_release:tutorial.Player.PhoneNumber.number)
  return number_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Player_PhoneNumber::set_allocated_number(std::string* number) {
  if (number != nullptr) {
    
  } else {
    
  }
  number_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), number,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (number_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tutorial.Player.PhoneNumber.number)
}

// .tutorial.Player.PhoneType type = 2;
inline void Player_PhoneNumber::clear_type() {
  type_ = 0;
}
inline ::tutorial::Player_PhoneType Player_PhoneNumber::_internal_type() const {
  return static_cast< ::tutorial::Player_PhoneType >(type_);
}
inline ::tutorial::Player_PhoneType Player_PhoneNumber::type() const {
  // @@protoc_insertion_point(field_get:tutorial.Player.PhoneNumber.type)
  return _internal_type();
}
inline void Player_PhoneNumber::_internal_set_type(::tutorial::Player_PhoneType value) {
  
  type_ = value;
}
inline void Player_PhoneNumber::set_type(::tutorial::Player_PhoneType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:tutorial.Player.PhoneNumber.type)
}

// -------------------------------------------------------------------

// Player_Item

// uint64 id = 1;
inline void Player_Item::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t Player_Item::_internal_id() const {
  return id_;
}
inline uint64_t Player_Item::id() const {
  // @@protoc_insertion_point(field_get:tutorial.Player.Item.id)
  return _internal_id();
}
inline void Player_Item::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void Player_Item::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:tutorial.Player.Item.id)
}

// int32 itemTid = 2;
inline void Player_Item::clear_itemtid() {
  itemtid_ = 0;
}
inline int32_t Player_Item::_internal_itemtid() const {
  return itemtid_;
}
inline int32_t Player_Item::itemtid() const {
  // @@protoc_insertion_point(field_get:tutorial.Player.Item.itemTid)
  return _internal_itemtid();
}
inline void Player_Item::_internal_set_itemtid(int32_t value) {
  
  itemtid_ = value;
}
inline void Player_Item::set_itemtid(int32_t value) {
  _internal_set_itemtid(value);
  // @@protoc_insertion_point(field_set:tutorial.Player.Item.itemTid)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Player_MobilePhone

// string device = 1;
inline void Player_MobilePhone::clear_device() {
  device_.ClearToEmpty();
}
inline const std::string& Player_MobilePhone::device() const {
  // @@protoc_insertion_point(field_get:tutorial.Player.MobilePhone.device)
  return _internal_device();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Player_MobilePhone::set_device(ArgT0&& arg0, ArgT... args) {
 
 device_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tutorial.Player.MobilePhone.device)
}
inline std::string* Player_MobilePhone::mutable_device() {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:tutorial.Player.MobilePhone.device)
  return _s;
}
inline const std::string& Player_MobilePhone::_internal_device() const {
  return device_.Get();
}
inline void Player_MobilePhone::_internal_set_device(const std::string& value) {
  
  device_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Player_MobilePhone::_internal_mutable_device() {
  
  return device_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Player_MobilePhone::release_device() {
  // @@protoc_insertion_point(field_release:tutorial.Player.MobilePhone.device)
  return device_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Player_MobilePhone::set_allocated_device(std::string* device) {
  if (device != nullptr) {
    
  } else {
    
  }
  device_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tutorial.Player.MobilePhone.device)
}

// -------------------------------------------------------------------

// Player_Watch

// string device = 1;
inline void Player_Watch::clear_device() {
  device_.ClearToEmpty();
}
inline const std::string& Player_Watch::device() const {
  // @@protoc_insertion_point(field_get:tutorial.Player.Watch.device)
  return _internal_device();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Player_Watch::set_device(ArgT0&& arg0, ArgT... args) {
 
 device_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tutorial.Player.Watch.device)
}
inline std::string* Player_Watch::mutable_device() {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:tutorial.Player.Watch.device)
  return _s;
}
inline const std::string& Player_Watch::_internal_device() const {
  return device_.Get();
}
inline void Player_Watch::_internal_set_device(const std::string& value) {
  
  device_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Player_Watch::_internal_mutable_device() {
  
  return device_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Player_Watch::release_device() {
  // @@protoc_insertion_point(field_release:tutorial.Player.Watch.device)
  return device_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Player_Watch::set_allocated_device(std::string* device) {
  if (device != nullptr) {
    
  } else {
    
  }
  device_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tutorial.Player.Watch.device)
}

// -------------------------------------------------------------------

// Player_Wallet

// repeated .tutorial.Player.Item items = 1;
inline int Player_Wallet::_internal_items_size() const {
  return items_.size();
}
inline int Player_Wallet::items_size() const {
  return _internal_items_size();
}
inline void Player_Wallet::clear_items() {
  items_.Clear();
}
inline ::tutorial::Player_Item* Player_Wallet::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:tutorial.Player.Wallet.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_Item >*
Player_Wallet::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:tutorial.Player.Wallet.items)
  return &items_;
}
inline const ::tutorial::Player_Item& Player_Wallet::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::tutorial::Player_Item& Player_Wallet::items(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.Player.Wallet.items)
  return _internal_items(index);
}
inline ::tutorial::Player_Item* Player_Wallet::_internal_add_items() {
  return items_.Add();
}
inline ::tutorial::Player_Item* Player_Wallet::add_items() {
  ::tutorial::Player_Item* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:tutorial.Player.Wallet.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_Item >&
Player_Wallet::items() const {
  // @@protoc_insertion_point(field_list:tutorial.Player.Wallet.items)
  return items_;
}

// -------------------------------------------------------------------

// Player_Bag

// repeated .tutorial.Player.Wallet wallets = 1;
inline int Player_Bag::_internal_wallets_size() const {
  return wallets_.size();
}
inline int Player_Bag::wallets_size() const {
  return _internal_wallets_size();
}
inline void Player_Bag::clear_wallets() {
  wallets_.Clear();
}
inline ::tutorial::Player_Wallet* Player_Bag::mutable_wallets(int index) {
  // @@protoc_insertion_point(field_mutable:tutorial.Player.Bag.wallets)
  return wallets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_Wallet >*
Player_Bag::mutable_wallets() {
  // @@protoc_insertion_point(field_mutable_list:tutorial.Player.Bag.wallets)
  return &wallets_;
}
inline const ::tutorial::Player_Wallet& Player_Bag::_internal_wallets(int index) const {
  return wallets_.Get(index);
}
inline const ::tutorial::Player_Wallet& Player_Bag::wallets(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.Player.Bag.wallets)
  return _internal_wallets(index);
}
inline ::tutorial::Player_Wallet* Player_Bag::_internal_add_wallets() {
  return wallets_.Add();
}
inline ::tutorial::Player_Wallet* Player_Bag::add_wallets() {
  ::tutorial::Player_Wallet* _add = _internal_add_wallets();
  // @@protoc_insertion_point(field_add:tutorial.Player.Bag.wallets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_Wallet >&
Player_Bag::wallets() const {
  // @@protoc_insertion_point(field_list:tutorial.Player.Bag.wallets)
  return wallets_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Player_Box

// map<uint64, .tutorial.Player.Item> items = 1;
inline int Player_Box::_internal_items_size() const {
  return items_.size();
}
inline int Player_Box::items_size() const {
  return _internal_items_size();
}
inline void Player_Box::clear_items() {
  items_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Item >&
Player_Box::_internal_items() const {
  return items_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Item >&
Player_Box::items() const {
  // @@protoc_insertion_point(field_map:tutorial.Player.Box.items)
  return _internal_items();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Item >*
Player_Box::_internal_mutable_items() {
  return items_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Item >*
Player_Box::mutable_items() {
  // @@protoc_insertion_point(field_mutable_map:tutorial.Player.Box.items)
  return _internal_mutable_items();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Player_MyTrunk

// map<uint64, .tutorial.Player.Box> boxs = 1;
inline int Player_MyTrunk::_internal_boxs_size() const {
  return boxs_.size();
}
inline int Player_MyTrunk::boxs_size() const {
  return _internal_boxs_size();
}
inline void Player_MyTrunk::clear_boxs() {
  boxs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Box >&
Player_MyTrunk::_internal_boxs() const {
  return boxs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Box >&
Player_MyTrunk::boxs() const {
  // @@protoc_insertion_point(field_map:tutorial.Player.MyTrunk.boxs)
  return _internal_boxs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Box >*
Player_MyTrunk::_internal_mutable_boxs() {
  return boxs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Box >*
Player_MyTrunk::mutable_boxs() {
  // @@protoc_insertion_point(field_mutable_map:tutorial.Player.MyTrunk.boxs)
  return _internal_mutable_boxs();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Player

// uint64 id = 1;
inline void Player::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t Player::_internal_id() const {
  return id_;
}
inline uint64_t Player::id() const {
  // @@protoc_insertion_point(field_get:tutorial.Player.id)
  return _internal_id();
}
inline void Player::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void Player::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:tutorial.Player.id)
}

// string name = 2;
inline void Player::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Player::name() const {
  // @@protoc_insertion_point(field_get:tutorial.Player.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Player::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tutorial.Player.name)
}
inline std::string* Player::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tutorial.Player.name)
  return _s;
}
inline const std::string& Player::_internal_name() const {
  return name_.Get();
}
inline void Player::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Player::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Player::release_name() {
  // @@protoc_insertion_point(field_release:tutorial.Player.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Player::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tutorial.Player.name)
}

// string email = 3;
inline void Player::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& Player::email() const {
  // @@protoc_insertion_point(field_get:tutorial.Player.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Player::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tutorial.Player.email)
}
inline std::string* Player::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:tutorial.Player.email)
  return _s;
}
inline const std::string& Player::_internal_email() const {
  return email_.Get();
}
inline void Player::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Player::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Player::release_email() {
  // @@protoc_insertion_point(field_release:tutorial.Player.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Player::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tutorial.Player.email)
}

// repeated .tutorial.Player.PhoneNumber phones = 4;
inline int Player::_internal_phones_size() const {
  return phones_.size();
}
inline int Player::phones_size() const {
  return _internal_phones_size();
}
inline void Player::clear_phones() {
  phones_.Clear();
}
inline ::tutorial::Player_PhoneNumber* Player::mutable_phones(int index) {
  // @@protoc_insertion_point(field_mutable:tutorial.Player.phones)
  return phones_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_PhoneNumber >*
Player::mutable_phones() {
  // @@protoc_insertion_point(field_mutable_list:tutorial.Player.phones)
  return &phones_;
}
inline const ::tutorial::Player_PhoneNumber& Player::_internal_phones(int index) const {
  return phones_.Get(index);
}
inline const ::tutorial::Player_PhoneNumber& Player::phones(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.Player.phones)
  return _internal_phones(index);
}
inline ::tutorial::Player_PhoneNumber* Player::_internal_add_phones() {
  return phones_.Add();
}
inline ::tutorial::Player_PhoneNumber* Player::add_phones() {
  ::tutorial::Player_PhoneNumber* _add = _internal_add_phones();
  // @@protoc_insertion_point(field_add:tutorial.Player.phones)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_PhoneNumber >&
Player::phones() const {
  // @@protoc_insertion_point(field_list:tutorial.Player.phones)
  return phones_;
}

// map<uint64, .tutorial.Player.Item> items = 5;
inline int Player::_internal_items_size() const {
  return items_.size();
}
inline int Player::items_size() const {
  return _internal_items_size();
}
inline void Player::clear_items() {
  items_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Item >&
Player::_internal_items() const {
  return items_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Item >&
Player::items() const {
  // @@protoc_insertion_point(field_map:tutorial.Player.items)
  return _internal_items();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Item >*
Player::_internal_mutable_items() {
  return items_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_Item >*
Player::mutable_items() {
  // @@protoc_insertion_point(field_mutable_map:tutorial.Player.items)
  return _internal_mutable_items();
}

// .tutorial.Player.MobilePhone mobilePhone = 6;
inline bool Player::_internal_has_mobilephone() const {
  return msg_case() == kMobilePhone;
}
inline bool Player::has_mobilephone() const {
  return _internal_has_mobilephone();
}
inline void Player::set_has_mobilephone() {
  _oneof_case_[0] = kMobilePhone;
}
inline void Player::clear_mobilephone() {
  if (_internal_has_mobilephone()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.mobilephone_;
    }
    clear_has_msg();
  }
}
inline ::tutorial::Player_MobilePhone* Player::release_mobilephone() {
  // @@protoc_insertion_point(field_release:tutorial.Player.mobilePhone)
  if (_internal_has_mobilephone()) {
    clear_has_msg();
      ::tutorial::Player_MobilePhone* temp = msg_.mobilephone_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.mobilephone_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tutorial::Player_MobilePhone& Player::_internal_mobilephone() const {
  return _internal_has_mobilephone()
      ? *msg_.mobilephone_
      : reinterpret_cast< ::tutorial::Player_MobilePhone&>(::tutorial::_Player_MobilePhone_default_instance_);
}
inline const ::tutorial::Player_MobilePhone& Player::mobilephone() const {
  // @@protoc_insertion_point(field_get:tutorial.Player.mobilePhone)
  return _internal_mobilephone();
}
inline ::tutorial::Player_MobilePhone* Player::unsafe_arena_release_mobilephone() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tutorial.Player.mobilePhone)
  if (_internal_has_mobilephone()) {
    clear_has_msg();
    ::tutorial::Player_MobilePhone* temp = msg_.mobilephone_;
    msg_.mobilephone_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Player::unsafe_arena_set_allocated_mobilephone(::tutorial::Player_MobilePhone* mobilephone) {
  clear_msg();
  if (mobilephone) {
    set_has_mobilephone();
    msg_.mobilephone_ = mobilephone;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tutorial.Player.mobilePhone)
}
inline ::tutorial::Player_MobilePhone* Player::_internal_mutable_mobilephone() {
  if (!_internal_has_mobilephone()) {
    clear_msg();
    set_has_mobilephone();
    msg_.mobilephone_ = CreateMaybeMessage< ::tutorial::Player_MobilePhone >(GetArenaForAllocation());
  }
  return msg_.mobilephone_;
}
inline ::tutorial::Player_MobilePhone* Player::mutable_mobilephone() {
  ::tutorial::Player_MobilePhone* _msg = _internal_mutable_mobilephone();
  // @@protoc_insertion_point(field_mutable:tutorial.Player.mobilePhone)
  return _msg;
}

// .tutorial.Player.Watch watch = 7;
inline bool Player::_internal_has_watch() const {
  return msg_case() == kWatch;
}
inline bool Player::has_watch() const {
  return _internal_has_watch();
}
inline void Player::set_has_watch() {
  _oneof_case_[0] = kWatch;
}
inline void Player::clear_watch() {
  if (_internal_has_watch()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.watch_;
    }
    clear_has_msg();
  }
}
inline ::tutorial::Player_Watch* Player::release_watch() {
  // @@protoc_insertion_point(field_release:tutorial.Player.watch)
  if (_internal_has_watch()) {
    clear_has_msg();
      ::tutorial::Player_Watch* temp = msg_.watch_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.watch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tutorial::Player_Watch& Player::_internal_watch() const {
  return _internal_has_watch()
      ? *msg_.watch_
      : reinterpret_cast< ::tutorial::Player_Watch&>(::tutorial::_Player_Watch_default_instance_);
}
inline const ::tutorial::Player_Watch& Player::watch() const {
  // @@protoc_insertion_point(field_get:tutorial.Player.watch)
  return _internal_watch();
}
inline ::tutorial::Player_Watch* Player::unsafe_arena_release_watch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tutorial.Player.watch)
  if (_internal_has_watch()) {
    clear_has_msg();
    ::tutorial::Player_Watch* temp = msg_.watch_;
    msg_.watch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Player::unsafe_arena_set_allocated_watch(::tutorial::Player_Watch* watch) {
  clear_msg();
  if (watch) {
    set_has_watch();
    msg_.watch_ = watch;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tutorial.Player.watch)
}
inline ::tutorial::Player_Watch* Player::_internal_mutable_watch() {
  if (!_internal_has_watch()) {
    clear_msg();
    set_has_watch();
    msg_.watch_ = CreateMaybeMessage< ::tutorial::Player_Watch >(GetArenaForAllocation());
  }
  return msg_.watch_;
}
inline ::tutorial::Player_Watch* Player::mutable_watch() {
  ::tutorial::Player_Watch* _msg = _internal_mutable_watch();
  // @@protoc_insertion_point(field_mutable:tutorial.Player.watch)
  return _msg;
}

// repeated .tutorial.Player.Bag bags = 8;
inline int Player::_internal_bags_size() const {
  return bags_.size();
}
inline int Player::bags_size() const {
  return _internal_bags_size();
}
inline void Player::clear_bags() {
  bags_.Clear();
}
inline ::tutorial::Player_Bag* Player::mutable_bags(int index) {
  // @@protoc_insertion_point(field_mutable:tutorial.Player.bags)
  return bags_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_Bag >*
Player::mutable_bags() {
  // @@protoc_insertion_point(field_mutable_list:tutorial.Player.bags)
  return &bags_;
}
inline const ::tutorial::Player_Bag& Player::_internal_bags(int index) const {
  return bags_.Get(index);
}
inline const ::tutorial::Player_Bag& Player::bags(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.Player.bags)
  return _internal_bags(index);
}
inline ::tutorial::Player_Bag* Player::_internal_add_bags() {
  return bags_.Add();
}
inline ::tutorial::Player_Bag* Player::add_bags() {
  ::tutorial::Player_Bag* _add = _internal_add_bags();
  // @@protoc_insertion_point(field_add:tutorial.Player.bags)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Player_Bag >&
Player::bags() const {
  // @@protoc_insertion_point(field_list:tutorial.Player.bags)
  return bags_;
}

// map<uint64, .tutorial.Player.MyTrunk> myTrunks = 9;
inline int Player::_internal_mytrunks_size() const {
  return mytrunks_.size();
}
inline int Player::mytrunks_size() const {
  return _internal_mytrunks_size();
}
inline void Player::clear_mytrunks() {
  mytrunks_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_MyTrunk >&
Player::_internal_mytrunks() const {
  return mytrunks_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_MyTrunk >&
Player::mytrunks() const {
  // @@protoc_insertion_point(field_map:tutorial.Player.myTrunks)
  return _internal_mytrunks();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_MyTrunk >*
Player::_internal_mutable_mytrunks() {
  return mytrunks_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::tutorial::Player_MyTrunk >*
Player::mutable_mytrunks() {
  // @@protoc_insertion_point(field_mutable_map:tutorial.Player.myTrunks)
  return _internal_mutable_mytrunks();
}

inline bool Player::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void Player::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline Player::MsgCase Player::msg_case() const {
  return Player::MsgCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tutorial

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tutorial::Player_PhoneType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tutorial::Player_PhoneType>() {
  return ::tutorial::Player_PhoneType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tutorial_2eplayer_2eproto
